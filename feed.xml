<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>午夜咖啡</title>
    <description>Jolestar 的个人博客，微信公众号 午夜咖啡 jolestar-blog，工具 架构 成长 思考
</description>
    <link>http://jolestar.com/</link>
    <atom:link href="http://jolestar.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 21 Feb 2023 16:53:20 +0800</pubDate>
    <lastBuildDate>Tue, 21 Feb 2023 16:53:20 +0800</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>Rollup Layer2 的模块化演进之路</title>
        <description>&lt;p&gt;本文尝试从演化角度讨论 Rollup Layer2 的发展以及演进，主要解答以下几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Rollup 是如何工作的&lt;/li&gt;
  &lt;li&gt;Rollup 的模块化演进&lt;/li&gt;
  &lt;li&gt;模块化带来的可能性&lt;/li&gt;
  &lt;li&gt;模块化应用的技术趋势&lt;/li&gt;
  &lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标读者：区块链技术从业者以及爱好者。本文首发于 RoochNetwork, &lt;a href=&quot;https://rooch.network/zh/blog/2023/2/14/The-Modular-Evolution-of-Rollup-Layer2/&quot;&gt;中文版&lt;/a&gt;, &lt;a href=&quot;https://rooch.network/blog/2023/2/14/The-Modular-Evolution-of-Rollup-Layer2/&quot;&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;rollup-是如何工作的&quot;&gt;Rollup 是如何工作的&lt;/h2&gt;

&lt;p&gt;区块链的“三难问题”一直是困扰业界的一个难题，如果我们认为 Layer1 区块链应该首先保证“去中心化”和“安全”，那将“扩展性”方案从 Layer1 迁移出来就是自然的选择了，于是有了 Layer2。那新的难题就是如何通过 Layer1 来保证 Layer2 的安全。&lt;/p&gt;

&lt;p&gt;最初有一种想法是定时将 Layer2 应用的状态树根写到 Layer1，这样可以通过状态证明来校验应用的状态，类似于交易所储备金证明。但这种方式第三方无法通过公开的方式验证两次状态转换是正确的。&lt;/p&gt;

&lt;p&gt;为了更深入的探讨这个问题，我们抽象一下，任何程序的状态都可以通过一个状态转换公式表达：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-math&quot;&gt;σt+1 ≡ Υ(σt, T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个公式来自于 Ethereum 黄皮书，但它可以代表任意的程序。在这里 Υ 代表程序，σ 代表状态。状态 σt+1 由程序 Y 通过状态 σt 和交易 T 计算得出。交易 T 代表程序的输入。&lt;strong&gt;任意时候，如果 σt 是确定的，程序 Y 是确定的，T 是确定的，那 σt+1 就是确定的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以要提供公开的可验证性，关键是 Y 要公开可用，历史上所有的 T 要公开可用并且顺序确定，中间的状态可通过 Y 和 T 重新计算得到。而程序的公开可用我们可以通过开源来实现，关键是 T 公开可用如何保证，这就引入了数据可用性（DA）的概念。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据可用性&lt;/strong&gt;需要有个公开的不可篡改的账本来记录应用的交易。自然想到，区块链账本就是这样一个系统，于是将 Layer2 的交易写回 Layer1，保证数据可用性，这也就是 Rollup 名称的来源。&lt;/p&gt;

&lt;p&gt;所以 Layer2 系统中需要有个角色收集用户的交易，进行排序并写入到 DA，这个角色叫 &lt;strong&gt;定序器（Sequencer）&lt;/strong&gt;。这里的交易序列叫 &lt;strong&gt;Canonical Transaction Chain&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;保证了数据的可用性，每个人都可以通过自己运行程序执行交易来得到最终的状态。但这里并没有达成共识，因为每个人不确定自己得到的结果是否和其他人的结果一致，毕竟软件或者硬件故障也可能导致数据不一致。所以需要另外一个角色将交易执行后的状态树根定时公布出来，供大家校验自己的状态，这个角色叫 &lt;strong&gt;提案者（Proposer）&lt;/strong&gt;。这里每次提交的状态也构成了一个状态序列，和交易序列对应，叫 &lt;strong&gt;State Commitment Chain&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;到这里，我们达到了应用的可验证性。如果某个人运行的结果和 Proposer 提交的状态不一致，并确定不是自己的问题，那就是 Proposer 作弊或者出错了，那怎么让别人也知道呢？这就需要引入&lt;strong&gt;仲裁者（Arbitrator）&lt;/strong&gt;的角色。仲裁者需要是一个可信第三方，链上合约正好可以承担这个角色。&lt;/p&gt;

&lt;p&gt;仲裁有两个方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Proposer 每次提交状态的时候，同时提供与前一次状态之间的状态转换有效证明（Validity Proof），链上的仲裁合约进行校验。有效证明一般通过 Zero knowledge 技术生成，这种叫 ZK Rollup。&lt;/li&gt;
  &lt;li&gt;先假定 Proposer 的结果是对的，但如果发现不一致，则提交欺诈证明（Fraud Proof），由仲裁合约进行判定。如果仲裁合约判定 Proposer 作弊，则对 Proposer 进行惩罚，并将 State Commitment Chain 回滚到欺诈交易之前的状态。当然，为了保证安全，一般会设置一个比较长的挑战周期来达到链上交易结算的最终确定性。这种叫 Optimistic Rollup。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们还需要实现 Layer1 和 Layer2 之间的资产互通。于是构建一个 Layer1 到 Layer2 之间的桥，通过状态证明来进行资产结算。而 Layer2 在 Layer1 的状态根由 Layer1 的仲裁合约保证，我们可以认为这个桥的安全也受仲裁合约保证。&lt;/p&gt;

&lt;p&gt;至此，我们得到了一个由 Layer1 保证安全，并且可以和 Layer1 进行资产互通的 Rollup Layer2 方案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/blog/modular/rollup-layer2.svg&quot; alt=&quot;Rollup layer2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然，Rollup 方案也做了一些妥协：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将交易写入 Layer1，也就代表 Layer2 的扩展性依然受 Layer1 区块大小限制。以 Ethereum 为例，某个 Layer2 完全占据 Ethereum 的所有区块，能提供的平均 TPS 也才数百，扩展性受 DA 限制。&lt;/li&gt;
  &lt;li&gt;为了节省 Gas 费，Sequencer 会将交易批量写入 DA，而在写入 DA 之前，Sequencer 有可能通过调整交易的顺序来作弊。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里总结一下 Layer2 的安全以及交易的最终确定性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果用户自己运行了一个 Layer2 的节点，并且忠实地按照 DA 的交易顺序执行，用户可以认为交易是即时确认并且达到最终确定的，因为如果用户执行的结果和 Proposer 不一样，说明 Proposer 作弊，需要回滚链上的状态，最终会和用户自己的节点执行的结果一样。 这里主要的风险点在于前面提到的，如果实时从 Sequencer 同步数据， Sequencer 调整尚未写入 DA 的交易的顺序带来的风险。&lt;/li&gt;
  &lt;li&gt;如果用户自己无法运行节点，需要依赖一个 RPC 提供方，用户需要承担一定的信任风险。但这个风险和用户信任 Layer1 的 RPC 节点带来的风险类似。这里额外的风险依然是 Sequencer 丢弃交易或者重排交易带来的风险。&lt;/li&gt;
  &lt;li&gt;如果 Proposer 出错，但没有节点发起挑战，超过了挑战期，这时候错误的状态无法回滚，只能通过社会共识硬分叉方式来修复状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;rollup-的模块化演进&quot;&gt;Rollup 的模块化演进&lt;/h2&gt;

&lt;p&gt;根据前面的分析，Rollup 解决方案中，链上的多个合约承担不同的职能，代表不同的模块。那自然想到，能否将模块拆分到多个链，从而获得更高的扩展性。这就是模块化区块链以及模块化 Rollup 的思路。&lt;/p&gt;

&lt;p&gt;模块化在这里有两层含义：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过模块化设计，让系统变为一个可拔插的系统。开发者可以通过模块的组装，满足不同的应用场景需求。&lt;/li&gt;
  &lt;li&gt;基于 1 提供的能力，模块层的实现并不绑定在同一个 Layer1 上，从而得到更好的扩展性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可以认为有三个主要的模块层：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;数据可用层（Data Availability）&lt;/strong&gt;： 保证执行层的交易数据可以通过公开的方式获取，以及保证交易的序列。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;结算层（Settlement）&lt;/strong&gt;：实现 Layer1 和 Layer2 之间的资产和状态结算。它包含 State Commitment Chain 和 Bridge。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;仲裁层（Arbitration）&lt;/strong&gt;：校验欺诈证明，并做出裁决（Optimistic）或者校验有效证明（ZK）。仲裁层要有能力操控 State Commitment Chain。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;da-模块化&quot;&gt;DA 模块化&lt;/h3&gt;

&lt;p&gt;将 DA 职能迁移出来，用一个独立的解决方案，获得的首要好处是 Layer2 的交易 Gas 费至少降低一个数量级。&lt;/p&gt;

&lt;p&gt;从安全方面来看，即便是 DA 链的去中心化弱于 Ethereum，但 DA 层对安全的保证主要是挑战期内的交易，过了挑战期后，DA 主要是为了方便其他节点同步数据，对安全并没有保障作用，所以去中心化的要求可以降低一个层次。&lt;/p&gt;

&lt;p&gt;DA 专用链可以提供更高的存储带宽和更低的存储成本，并且针对多个应用共享 DA 进行专门的设计。这也是当前如 Celestia、Polygon Avail 这样的 DA 链的立足点。&lt;/p&gt;

&lt;p&gt;将 DA 层拆分出去后，我们得到了下图的架构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/blog/modular/modular-rollup-layer2.svg&quot; alt=&quot;Modular Rollup layer2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中由 DA 来承担保存 Canonical Transaction Chain 的职责，而给 Layer1 留了一个 L1ToL2 Transaction Queue 来实现 Layer1 和 Layer2 之间的消息通信，用户也可以直接写交易给这个 Queue，确保 Layer2 的 Permissionless，Sequencer 无法审核用户或者交易。&lt;/p&gt;

&lt;p&gt;但这里会引入一个新的难题，如果 Sequencer 写入 DA 的交易序列和 Proposer 执行的交易序列不一致，仲裁合约如何判定？一种方案是 DA 链和仲裁链之间有一个跨链桥，实现在仲裁合约中校验 DA 链提供的数据证明。但这种方案依赖 DA 和其他链之间的跨链桥的实现，DA 的方案选型会受限制。另外一种方案是引入排序证明。&lt;/p&gt;

&lt;h3 id=&quot;排序证明sequence-proof&quot;&gt;排序证明（Sequence Proof）&lt;/h3&gt;

&lt;p&gt;我们可以认为 Sequencer 实际上也属于 DA 方案的一部分，它相当于一个 App-Specific 的 DA，主要基于以下理由：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sequencer 需要提供批量写入 DA 链之前这段时间内的 DA 保证。&lt;/li&gt;
  &lt;li&gt;Sequencer 需要负责交易的验证，排序，以及最终写入 DA。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果要求 Sequencer 给每个交易生成一个 Sequence Proof，则可以解决两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对尚未写入 DA 链的交易提供了保证，使 Sequencer 不敢随意调整交易的顺序或者丢弃交易。&lt;/li&gt;
  &lt;li&gt;如果 DA 链和仲裁链之间没有跨链桥，则可以通过 Sequence Proof 的挑战机制来保证数据可用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Sequence Proof&lt;/strong&gt; 具有以下特性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;它携带 Sequencer 的签名，证明它是某个 Sequencer 发出的。&lt;/li&gt;
  &lt;li&gt;它可以证明某个交易在全部交易序列中的位置。&lt;/li&gt;
  &lt;li&gt;它是累加器（Accumulator）证明的一种。每个交易累加后会生成新的累加结果，与该交易之前所有历史交易相关，使得其难以篡改。累加器的可选方案之一是默克尔累加器（Merkle Accumulator），累加结果表现为默克尔树的根。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sequence Proof 的工作原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/diagram/rooch-sequence-proof.svg&quot; alt=&quot;Sequence Proof&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户或者执行节点提交交易给 Sequencer，Sequencer 将 Sequence Proof 返回给用户，同时同步给其他节点。如果 Sequencer 在提交给 DA 之前丢弃或者篡改了交易的顺序，用户或者其他节点可以提交 Sequence Proof 给仲裁合约，从而惩罚 Sequencer。仲裁合约需要从 State Commitment Chain 合约中读取交易累加器的根，从而校验 Sequence Proof。&lt;/p&gt;

&lt;p&gt;分场景探讨一下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sequencer 丢弃或者重排了用户交易。这会导致 Sequencer 在同一个位置生成了两个 Sequence Proof。用户提交 Sequence Proof 给仲裁合约，Sequencer 需要提供该交易被包含在最新的交易累加器的根中的证明，如果不能给出，则惩罚 Sequencer。&lt;/li&gt;
  &lt;li&gt;Sequencer 没有正确地将交易写入 DA 链，和 Proposer 合谋隐藏交易。如果仲裁链和 DA 链有桥，则通过桥来验证，惩罚 Sequencer。否则用户可以发起挑战，要求 Sequencer 给出某个位置的交易的证明以及原始信息。但这种情况仲裁合约无法判断用户是否是恶意挑战，所以如果 Sequencer 给出数据则不惩罚 Sequencer。而对用户来说，恶意挑战损人损己，也缺少经济动力。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们通过引入 Sequence Proof 让 Layer2 的协议变得更安全。&lt;/p&gt;

&lt;h3 id=&quot;交易流水线transaction-pipeline以及并行执行parallel-execution&quot;&gt;交易流水线（Transaction Pipeline）以及并行执行（Parallel Execution）&lt;/h3&gt;

&lt;p&gt;将 Sequencer 划分给 DA，只负责交易的验证和排序，带来的另外一个好处是容易实现交易的流水线以及并行执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/diagram/rooch-txn-pipeline.svg&quot; alt=&quot;Transaction Pipeline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;验证交易时，需要验证签名和是否有足够的 Gas 费，而 Gas 费的校验需要依赖状态。如果我们为了保证验证交易不会被执行交易阻塞，允许 Sequencer 验证交易依赖的状态和最新状态之间有一定的延迟（秒级），会导致 Gas 校验会不太准确，有被 DDoS 攻击的风险。&lt;/p&gt;

&lt;p&gt;但我们认为 Sequencer 属于 DA 是一个正确的方向，所以值得我们进一步研究。比如可以将交易费中 DA 部分拆分出来，通过 UTXO（Sui Move Object） 表达，则可以降低 Gas 费检测成本。&lt;/p&gt;

&lt;p&gt;Sequencer 给交易排序然后输出成交易流水线，然后同步给 Proposer 以及其他节点。每个节点可以根据自己的服务器情况来选择并行方案。每个节点需要保证：只并行没有因果关系的交易，有因果关系的交易必须按 Sequencer 的顺序执行，那最终的结果就是一致的。&lt;/p&gt;

&lt;p&gt;Proposer 需要定时提交状态树的根，以及累加器的根到链上的 State Commitment Chain 合约中。&lt;/p&gt;

&lt;p&gt;于是我们得到了一个低 Gas 费，高 TPS，并且更安全的模块化 Layer2： &lt;strong&gt;Rooch&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/diagram/rooch-architecture.svg&quot; alt=&quot;Rooch Architecture&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MoveOS：它包含 MoveVM 以及 StateDB，是系统的执行以及状态存储引擎。StateDB 由两层稀疏默克尔树构建，可以提供状态证明。根据前面的分析可得出，状态树以及状态证明是 Rollup 应用不可或缺的组件。&lt;/li&gt;
  &lt;li&gt;RPC：对外提供查询，提交交易，以及订阅服务。可以通过代理方式兼容其他链的 RPC 接口。&lt;/li&gt;
  &lt;li&gt;Sequencer：验证交易，给交易排序，提供 Sequence Proof，将交易流式输出到 Transaction Pipeline。&lt;/li&gt;
  &lt;li&gt;Proposer：从 Transaction Pipeline 获取交易，批量执行，定期提交到链上的 State Commitment Chain。&lt;/li&gt;
  &lt;li&gt;Challenger：从 Transaction Pipeline 获取交易，批量执行，和 State Commitment Chain 比较，决定是否发起挑战。&lt;/li&gt;
  &lt;li&gt;DA &amp;amp; Settlement &amp;amp; Arbitration Interface：对不同的模块层的抽象和封装，保证在不同的实现之间切换时不影响上层业务逻辑。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;支持多链的交互式欺诈证明&quot;&gt;支持多链的交互式欺诈证明&lt;/h3&gt;

&lt;p&gt;Optimistic Rollup 方案中，链上的仲裁合约如何判定链下的交易执行出错，一直是一个难题。最初的想法是 Layer1 上重新执行一遍 Layer2 的交易，但这种方案的难题是 Layer1 的合约要模拟 Layer2 的交易执行，成本很高，也会限制 Layer2 交易的复杂度。&lt;/p&gt;

&lt;p&gt;最后业界摸索出一种交互式证明的方案。因为任何复杂的交易，最终会转换成机器指令执行，如果我们找到产生分歧的指令，则只需要在链上模拟执行指令即可。&lt;/p&gt;

&lt;p&gt;还用上面那个状态转换公式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-math&quot;&gt;σt+1 ≡ Υ(σt, T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 Υ 代表指令，T 代表指令输入，σ 代表指令所依赖的内存状态。如果在执行过程中，给每个 σ 都生成一个状态证明。 控辩双方可以通过交互，发现双方的分歧点 m，将 m-1 的状态 σ 以及指令 m 提交到链上仲裁合约模拟执行，仲裁合约执行后就可以给出判定。&lt;/p&gt;

&lt;p&gt;所以剩下的问题就是通过什么方式来生成证明，主要有两个方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;直接在合约语言虚拟机中实现，比如 Arbitrum 的 AVM，Fuel 的 FuelVM。&lt;/li&gt;
  &lt;li&gt;基于已有的指令集实现一个模拟器，在模拟器中提供证明能力。如 Optimism 的基于 MIPS 指令的 cannon，Arbitrum 新的基于 WASM 指令的 Nitro，以及 Rooch 的基于 MIPS 指令的 OMO。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/diagram/rooch-omo.svg&quot; alt=&quot;OMO&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OMO 是一个拥有单步状态证明能力的通用字节码模拟器，为多链执行环境设计。有了 OMO 的支持，可以实现仲裁层的模块化。任意支持图灵完备合约的链，都可以在合约中模拟 OMO 的指令，作为仲裁层。&lt;/p&gt;

&lt;h3 id=&quot;zk--optimistic-组合方案&quot;&gt;ZK + Optimistic 组合方案&lt;/h3&gt;

&lt;p&gt;业界一直在争论 Optimistic Rollup 和 ZK Rollup 孰优孰劣，但我们认为将二者结合起来可以兼得两种方案的优点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/diagram/rooch-zk-optimisc.svg&quot; alt=&quot;ZK + Optimistic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在前面的 Optimistic 方案基础上，我们再引入一个新的角色，ZK Prover。它批量给 Proposer 提交的交易状态生成有效证明，并提交给仲裁合约。仲裁合约验证后，就可以判定该交易在 Layer1 上达到了最终确定性，可以进行 Layer2 到 Layer1 的提款交易的结算。&lt;/p&gt;

&lt;p&gt;这种方案的优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不会因为 ZK 的性能问题限制 Layer2 的整体吞吐。&lt;/li&gt;
  &lt;li&gt;可以通过 ZK 缩短 Optimistic 的挑战周期，提升用户体验。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 ZK 的方案以及硬件加速成熟之前，我们可以先通过 Optimistic 构建生态，同时模块化方案可以让 ZK 最后无缝接入进来。&lt;/p&gt;

&lt;h3 id=&quot;多链结算&quot;&gt;多链结算&lt;/h3&gt;

&lt;p&gt;如果我们进一步思考模块化的趋势，自然想到，既然 DA 可以迁移到别的链，那结算层是否也可以部署到别的链？&lt;/p&gt;

&lt;p&gt;Layer1 和 Layer2 之间的资产结算主要依赖两个组件，一个是 Bridge，一个是 State Commitment Chain，从 Bridge 结算的时候，需要依赖 State Commitment Chain 校验 Layer2 的状态证明。 Bridge 当然可以部署到多个链，但 State Commitment Chain 只能有一个权威的版本，由仲裁合约保证安全。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/diagram/rooch-multi-chain-layer2.svg&quot; alt=&quot;Multi chain Settlement&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个方向还需要深入研究，但有个初步的方案。其他链上的 State Commitment Chain 都是仲裁链（Ethereum）上的镜像。这个镜像并不需要同步全部的 Layer2 State Root 到其他链，而是用户按需通过 Ethereum 的状态证明做映射。&lt;/p&gt;

&lt;p&gt;当然，其他链上还需要能校验 Ethereum 上的状态证明，所以需要知道 Ethereum 上的状态根。当前，将 Ethereum 上的状态根同步到其他节点有两个方案：1. 依赖 Oracle。2. 嵌入 Ethereum 轻节点，校验 Ethereum 的区块头。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://rooch.network/diagram/rooch-multi-chain-settlement.svg&quot; alt=&quot;Multi chain Settlement&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样我们就可以得到一个支持多链结算，但安全由 Ethereum 保证的 Layer2 方案。&lt;/p&gt;

&lt;p&gt;这种方案和跨链的区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果是依赖中继链的跨链方案，可以认为 Layer2 替代了中继链，是一个安全受仲裁合约保证的中继层。&lt;/li&gt;
  &lt;li&gt;如果是链间互相校验状态证明的跨链方案，多链结算方案和它共享状态根同步的技术方案，但简化了许多。因为在多链结算方案中，状态根的同步需求是单向的，只需要从仲裁链同步到其他链，不是两两互相同步。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;模块化带来的可能性&quot;&gt;模块化带来的可能性&lt;/h2&gt;

&lt;p&gt;通过模块化，开发者可以通过 Rooch 组合出不同的应用。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Rooch Ethereum Layer2&lt;/strong&gt; = Rooch + Ethereum(Settlement+Arbitration) + DA&lt;br /&gt;
这是 Rooch 首先要运行的网络。提供一个由 Ethereum 安全保证的，可以和 Ethereum 上的资产互通的 Move 运行平台。未来可以扩展到多链结算。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rooch Layer3 Rollup DApp&lt;/strong&gt; = Rooch + DApp Move Contract + Rooch Ethereum Layer2(Settlement + Arbitration) + DA
如果应用把自己的结算和仲裁部署到 Rooch Layer2，它就是一个 Rooch 的 Layer3 应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;XChain Rollup DApp&lt;/strong&gt; = Rooch + DApp Move Contract + XChain(Settlement + Arbitration) + DA
任意链都可以通过 Rooch 来给开发者提供一套基于 Move 语言的 Rollup DApp 工具包。开发者只需要通过 Move 语言编写自己的应用逻辑，就可以运行一个安全受 XChain 保障的，资产可以和 XChain 互通的，独立环境的 Rollup 应用。当然这个需要和各公链的开发者来协同开发。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Sovereign Rollup DApp&lt;/strong&gt; = Rooch + DApp Move Contract + DA
应用也可以将 Rooch 作为 Sovereign Rollup SDK，不部署 Bridge 以及 Arbitration 合约，State Commitment Chain 也保存在 DA，保证可验证性，由社会共识保证安全。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Arweave SCP DApp&lt;/strong&gt; = Rooch + DApp Move Contract + DA（Arweave）
SCP 和 Sovereign Rollup 思路类似，SCP 要求应用程序的代码也要保存到 DA。而 Rooch 中合约部署和升级都是交易，合约代码在交易中，都会写到 DA 层，所以我们认为符合 SCP 的标准。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Move DApp Chain&lt;/strong&gt; = Cosmos SDK + MoveOS + DApp Move Contract
MoveOS 可以作为一个独立的 Move 运行环境嵌入到任意的链的运行环境中，去构建应用链或者新的公链。&lt;/li&gt;
  &lt;li&gt;非区块链项目
非区块链项目，可以把 MoveOS 作为一个可以带有数据校验能力以及存储证明能力的数据库使用。比如用它做一个本地的博客系统，数据结构和业务逻辑通过 Move 表达。等未来基础设施成熟，则可以直接和区块链生态对接起来。再比如可以用它做云计算中的 FaaS 服务，开发者通过 Move 编写 FaaS 中的 Function，平台托管状态，用户间的 Function 还可以互相组合调用。更多的可能性需要大家探索。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Rooch 的模块化方案可以适应于不同类型以及阶段的应用。比如开发者可以先通过部署合约在 Rooch Ethereum Layer2 上验证自己的想法，等成长起来后，将应用迁移到独立的基于 Rooch 搭建的 App-Specific Rollup 中。&lt;/p&gt;

&lt;p&gt;再或者开发者直接通过 Sovereign Rollup 方式启动应用，因为应用早期对安全性要求不高，也没有和其他链互通资产的需求，先做到可验证。等应用成长起来，有了互通资产的需求，对安全性要求变高，这时候可以启用结算以及仲裁模块从而保证资产的安全。&lt;/p&gt;

&lt;h2 id=&quot;模块化应用的技术趋势&quot;&gt;模块化应用的技术趋势&lt;/h2&gt;

&lt;h3 id=&quot;da-层潜力尚待挖掘&quot;&gt;DA 层潜力尚待挖掘&lt;/h3&gt;

&lt;p&gt;由前面的分析可以看出，无论哪种组合方式，都依赖 DA。DA 在去中心化应用中扮演的角色类似于 Web2 系统的日志平台，可以用来做审计，支持大数据分析，进行 AI 训练等。未来会有很多应用和服务围绕 DA 建立起来。当前已有 Celestia，Polygoin avail，未来还会有 EigenLayer，Ethereum danksharding 等。&lt;/p&gt;

&lt;p&gt;根据前面的分析，我们得出 Sequencer 的角色应该属于 DA 的一部分，如果 DA 层能为应用提供交易校验能力，并且有足够的性能，实际上完全可以由 DA 来承担 Sequencer 的职责，用户直接写交易到 DA。当然能否使用应用的 Token 付 DA 的 Gas 费是另外一个需要解决的问题。&lt;/p&gt;

&lt;h3 id=&quot;dapp-编程语言会爆发&quot;&gt;DApp 编程语言会爆发&lt;/h3&gt;

&lt;p&gt;新的应用形态会促使新的编程语言爆发，这在 Web2 时代已经验证。而 Move 会成为构建 Web3 DApp 的最佳语言。除了 Move 本身的语言特性外，还基于以下理由：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DApp 用同一种语言可以快速积累应用所需要的基础库，形成生态聚集效应。所以一开始支持多语言不是个好策略。&lt;/li&gt;
  &lt;li&gt;去中心化应用至少要保证可验证性，而智能合约语言可以让开发者在保证可验证性方面减少许多心智负担。&lt;/li&gt;
  &lt;li&gt;Move 的平台无关性，可以让它很容易适配到不同的平台，不同的应用中。&lt;/li&gt;
  &lt;li&gt;Move 的状态是结构化的，有利于 DApp 的数据结构表达以及存储检索。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;我在 17 年底进入区块链领域，当时业界有非常多的团队尝试在区块链领域构建应用。可惜当时基础设施尚不完备，业界尚未摸索出一个可复制的构建应用的模式，大多数应用类项目以失败告终，打击了开发者和投资者。区块链上的应用应该如何构建出来？这个问题一直让我思考了五年。&lt;/p&gt;

&lt;p&gt;而现在，随着 Layer1，Layer2 以及智能合约，模块化基础设施的成熟，这个问题的答案也逐渐清晰起来。&lt;/p&gt;

&lt;p&gt;希望在即将到来的 Web3 DApp 爆发潮中， Rooch 可以助开发者一臂之力，让应用更快的构建，真正的落地。&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Feb 2023 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/the-modular-evolution-of-rollup-layer2/</link>
        <guid isPermaLink="true">http://jolestar.com/the-modular-evolution-of-rollup-layer2/</guid>
        
        <category>rooch</category>
        
        <category>layer2</category>
        
        <category>modular-rollup</category>
        
        <category>move</category>
        
        <category>dapp</category>
        
        
      </item>
    
      <item>
        <title>为什么是 Move 之编程语言的生态构建</title>
        <description>&lt;p&gt;作为一个 Move 的鼓吹者，每次给开发者推广 Move 的时候都会遇到这样的问题。Move 有什么优势吗？为什么是 Move？就像你给好友介绍自己的新恋人，总会遇到类似的问题。但这种问题其实不易回答，如果一条一条列举优缺点，总是会有人质疑，毕竟新语言的生态都不成熟，选择只能基于它的潜力来判断。我先说一个论断： Move 是最有潜力构建出 Solidity 这样的生态系统，甚至超越的智能合约编程语言。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标读者：开发者以及对区块链领域的技术感兴趣的朋友。本文希望尽量以通俗的方式说明智能合约当前遇到的难题以及 Move 的一些尝试，尽量少用代码，期望不懂编程语言的朋友也能大致理解，但这个很难，希望读者给一点反馈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;智能合约的两条路&quot;&gt;智能合约的两条路&lt;/h2&gt;

&lt;p&gt;如果把时间拖回到几年前，新公链上支持图灵完备智能合约的编程语言主要有两种方式：&lt;/p&gt;

&lt;p&gt;一种是基于现有的编程语言进行裁剪，然后运行在 WASM 等通用的虚拟机里。这种方案的优势是可以沿用当前编程语言以及 WASM 虚拟机的生态。&lt;/p&gt;

&lt;p&gt;一种是新造一个专门的智能合约编程语言，以及虚拟机，从头构造语言以及虚拟机生态。Solidity 就是这条路线，Move 也是这条路线。&lt;/p&gt;

&lt;p&gt;那时候大家普遍其实不太看好 Solidity&amp;amp;Evm 生态，觉得 Solidity 除了用来发 Token，貌似也没有什么用，性能也不好，工具也孱弱，像是个玩具。很多链的目标是让开发者用已有的语言来进行智能合约编程，觉得前一条路更被看好，很少有新公链直接复制 Solidity&amp;amp;Evm。&lt;/p&gt;

&lt;p&gt;但经过几年的发展，尤其 DeFi 崛起之后，大家突然发现 Solidity 的生态不一样了。而走前一条路的智能合约生态反倒没有成长起来，为什么呢？我总结有几个原因。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;区块链的程序运行环境和面向操作系统的程序运行环境区别很大，如果抛弃掉操作系统的系统调用，文件IO，硬件，网络，并发等相关的库，再考虑链上的执行成本，已有编程语言能和智能合约共享的代码库非常少。&lt;/li&gt;
  &lt;li&gt;第一种方案理论上能支持的语言很多，但实际上带有 Runtime 的编程语言编译到 WASM 等虚拟机后文件会非常大，不适合区块链场景使用，能用的也主要是 C, C++, Rust 等。而这几种语言的学习门槛实际上并不比 Solidity 这种专门的智能合约编程语言的成本更低，并且同时支持多个语言可能会导致早期生态的割裂。&lt;/li&gt;
  &lt;li&gt;各链的状态处理机制不一样，即便都用都是 WASM 虚拟机，各链的智能合约应用也不能直接迁移，无法共享一个共同的编程语言以及开发者生态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对应用开发者来说，直接面对的就是智能合约编程语言，编程语言的基础库，有没有可复用的开源库。DeFi 的安全性要求智能合约代码要经过审计，而经过审计的代码每一行都代表着钱，大家基于已有的代码略做修改进行复制，就能降低审计成本。&lt;/p&gt;

&lt;p&gt;现在看来 Solidity 虽然走了一个看起来慢的路，但实际上更快的构建出了生态。现在很多人已经认为 Solidity&amp;amp;EVM 就是智能合约的终点了，很多链都开始兼容或者移植 Solidity&amp;amp;Evm。这时候，新的智能合约编程语言需要证明自己有更强的生态构建能力，才能说服大家关注与投入。&lt;/p&gt;

&lt;p&gt;那新的问题就是，一个编程语言语言，如何衡量它的生态构建能力？&lt;/p&gt;

&lt;h2 id=&quot;编程语言的生态构建能力&quot;&gt;编程语言的生态构建能力&lt;/h2&gt;

&lt;p&gt;编程语言的生态构建能力，简单的来说就是它的代码的复用能力，主要体现在两个方面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编程语言模块之间的依赖方式。&lt;/li&gt;
  &lt;li&gt;编程语言模块之间的组合方式。“可组合性”是智能合约标榜的一个特性，但实际上编程语言都有组合性，我们发明的 Interface, Trait 等都是为了更方便的组合。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先说说依赖方式，编程语言实现实现依赖主要通过三个方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过静态库（Static-Libraries）的方式，在编译期静态链接，将依赖打包在同一个二进制中。&lt;/li&gt;
  &lt;li&gt;通过动态库（Dynamic-Libraries）的方式，运行时动态链接，依赖并不在二进制中，但要预先在目标平台上部署。&lt;/li&gt;
  &lt;li&gt;通过远程调用（RPC）在运行期依赖。这里泛指各种可以远程调用的 API。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1，2 一般都用在基础库依赖的场景下。基础库一般是无状态的，因为应用如何处理状态，比如写哪个文件里，还是存哪个数据库表里，基础库是很难假设。这种调用是在同一个进程同一个方法调用的上下文里，共享调用栈，共享内存空间，没有安全隔离（或者说隔离很弱），需要可信环境。&lt;/p&gt;

&lt;p&gt;3 实际上调用的是另外的进程或者另外的机器上的进程，互相通过消息通信，各进程负责自己的状态，所以可以提供状态的依赖，调用也有安全隔离。&lt;/p&gt;

&lt;p&gt;这三种方法各有优劣。1 在最终二进制中包含依赖的库，优点是对目标平台的环境无依赖，但缺点是二进制比较大，2 的优势是二进制比较小，但对运行环境有前置要求，3 可以构建跨语言的依赖关系，一般用在跨服务，跨机构合作的场景中，为了方便开发者调用，一般通过 SDK 或者代码生成模拟成方法调用。&lt;/p&gt;

&lt;p&gt;技术历史上，很多编程语言，操作系统平台都花费了很大的精力想弥合远程调用和本地调用之间的差异，想实现无缝的远程调用和组合。随便举一些著名的技术词汇，COM(Component Object Model)/CORBA/SOAP/REST 等等，都是为了解决这些问题。虽然实现无缝调用组合的梦想破灭了，大家最后还是靠工程师人力拼接口，把整个 Web2 的服务给拼接在一起，但梦想的火种还在。&lt;/p&gt;

&lt;p&gt;而智能合约，给应用间的依赖方式带来了新变化。&lt;/p&gt;

&lt;h2 id=&quot;智能合约带来的改变&quot;&gt;智能合约带来的改变&lt;/h2&gt;

&lt;p&gt;传统的企业应用之间的依赖方式可以用下图表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/why-move/web2-system-rpc-call.png&quot; alt=&quot;web2 system rpc call&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;系统之间通过各种 RPC 协议把运行在不同的机器上的服务连接在一起。&lt;/li&gt;
  &lt;li&gt;机器之间有各种技术的，人工的“墙”进行隔离，保证安全。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而智能合约的运行环境是链的节点给构造出的沙箱环境，多个合约程序是运行在同一个进程内的不同的虚拟机沙箱中，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/why-move/blockchain-smartcontract-call.png&quot; alt=&quot;blockchain smart contract call&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;合约之间的调用是同一个进程内不同的智能合约虚拟机之间的调用。&lt;/li&gt;
  &lt;li&gt;安全依赖于智能合约虚拟机之间的隔离。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们以 Solidity 为例子，Solidity 的合约（表明为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contract&lt;/code&gt;  的模块）将自己的函数声明为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt;，然后其他合约就可以直接通过这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt; 方法调用该合约。以下图的一个 RPC 调用过程为例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/why-move/rpc.png&quot; alt=&quot;rpc&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;图片来源 https://docs.microsoft.com/en-us/windows/win32/rpc/how-rpc-works&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;链实际上接管了上图中，Client 和 Server 之间通信的所有过程，自动生成 stub，实现序列化和反序列化，真正让开发者感觉到远程调用就像本地方法调用一样。&lt;/p&gt;

&lt;p&gt;当然，技术并没有银弹，没有一劳永逸的方案，新的方案总带来新的难题需要解决。&lt;/p&gt;

&lt;h2 id=&quot;智能合约的依赖难题&quot;&gt;智能合约的依赖难题&lt;/h2&gt;

&lt;p&gt;通过前面的分析，我们理解了智能合约之间的调用实际上是一种类似于远程调用的方法。那如果像要通过库的方式进行依赖调用呢？&lt;/p&gt;

&lt;p&gt;在 Solidity 中，表明为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;library&lt;/code&gt;  的模块，就相当于静态库，它必须是无状态的。对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;library&lt;/code&gt;  的依赖会在编译期打包到最终的合约二进制中。&lt;/p&gt;

&lt;p&gt;这样带来的问题就是如果合约复杂，依赖过多，导致编译后的合约过大，无法部署。但如果拆成多个合约，则又无法直接共享状态，内部依赖变成远程服务间的依赖，增加了调用成本。&lt;/p&gt;

&lt;p&gt;那是不是可以走第二条动态库加载的路呢？比如 Ethereum 上的大部分合约都依赖了 SafeMath.sol 这个库，每个合约都包含了它的二进制，既然代码都在链上了，为什么不能直接共享呢？&lt;/p&gt;

&lt;p&gt;于是 Solidity 中提供了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delegatecall&lt;/code&gt; 的方法，类似于动态链接库的解决方案，把另外一个合约的代码，嵌入到当前合约调用的上下文中执行，让另外一个合约直接读写当前合约的状态。但这就有两个要求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用和被调用方要是完全信任的关系。&lt;/li&gt;
  &lt;li&gt;两个合约的状态要对齐。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非智能合约开发者可能不太理解这个问题，如果是 Java 开发者可以这样理解：Solidity 的每个合约都相当于一个 Class，它部署后运行起来是一个单例的 Object，如果想在运行时，加载另外一个 Class 的方法来修改当前 Object 里的属性，那这两个 Class 里定义的字段必须相同，并且新加载的方法相当于一个内部方法，Object 的内部属性完全对它可见。&lt;/p&gt;

&lt;p&gt;这样就限制了动态链接的使用场景和复用程度，现在主要用来做内部的合约升级。&lt;/p&gt;

&lt;p&gt;因为上面的原因，Solidity 很难像其他编程语言一样提供一个丰富的标准库（stdlib），提前部署到链上由其他合约依赖，只能提供有限的几个预编译方法。&lt;/p&gt;

&lt;p&gt;这也导致了 EVM 字节码的膨胀。很多本来可以通过 Solidity 代码从状态中获取的数据，被迫实现成了通过虚拟机指令从运行时上下文中获取。比如区块相关的信息本可以通过标准库里的系统合约从状态中获取，编程语言本身不需要知道区块相关的信息。&lt;/p&gt;

&lt;p&gt;这个问题是所有的链和智能合约编程语言都会遇到的问题。传统编程语言并没有考虑同一个方法调用栈内的安全问题（或者说考虑的比较少），搬到链上之后，也只能通过静态依赖，和远程依赖的方式解决依赖关系，一般连类似于 Solidity 中的 delegatecall 方案都很难提供。&lt;/p&gt;

&lt;p&gt;那我们如何才能做到在智能合约之间实现类似动态库链接的方式调用？合约之间的调用可以共享同一个方法调用栈，并且可以直接传递变量？&lt;/p&gt;

&lt;p&gt;这样做带来两个安全性方面的挑战：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;合约的状态的安全性要通过编程语言内部的安全性进行隔离，而不能依赖虚拟机进行隔离。&lt;/li&gt;
  &lt;li&gt;跨合约的变量传递需要保证安全，保证不能随意丢弃，尤其是表达资产类型的变量。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;智能合约的状态隔离&quot;&gt;智能合约的状态隔离&lt;/h2&gt;

&lt;p&gt;前面说到，智能合约实际上是把不同组织机构的代码放在同一个进程中执行，那合约的状态（简单理解就是合约执行时生成的结果，需要保存起来供下次执行的时候使用）的隔离就是必要的了，如果直接允许一个合约读写另外一个合约的状态，肯定带来安全问题。&lt;/p&gt;

&lt;p&gt;隔离方案理解起来其实也很简单，就是给每个合约一个独立的状态空间。执行智能合约的时候，将当前智能合约的状态空间和虚拟机绑定，这样智能合约就只能读取自己的状态了。如果要读取另外的合约，则需要前面提到的合约间的调用，实际上是在另外一个虚拟机里执行。&lt;/p&gt;

&lt;p&gt;但如果想要通过动态库的方式进行依赖的时候，这样的隔离就不够了。因为实际上，另外一个合约是在当前合约的执行栈中运行的，我们需要基于语言层面的隔离，而不是虚拟机的隔离。&lt;/p&gt;

&lt;p&gt;另外，基于合约的状态空间的隔离同时带来的一个问题是状态所有权的问题。这种情况下，所有的状态都属于合约，并没有区分合约的公共状态和个人的状态，给状态计费带来难题，长远来看会有状态爆炸的问题。&lt;/p&gt;

&lt;p&gt;那如何在智能合约语言层面做状态隔离呢？思路其实也很简单，基于类型。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;利用编程语言对类型提供的可见性的约束，这个特性大多数编程语言都支持。&lt;/li&gt;
  &lt;li&gt;利用编程语言对变量提供的可变性约束，许多编程语言区分引用的可变与不可变，比如 Rust。&lt;/li&gt;
  &lt;li&gt;提供基于类型为 Key 的外部存储，限制当前模块只能用自己定义的类型作为 Key 来读取外部存储。&lt;/li&gt;
  &lt;li&gt;在编程语言层面对类型提供声明 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;drop&lt;/code&gt; 的能力, 保证资产类的变量不可以被随意复制和丢弃。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Move 语言就是用了以上解决方案，其中第3，4点是 Move 特有的。这个解决方案其实也比较容易理解，如果不能在虚拟机层面给每个智能合约程序一个单独的状态空间，在合约内部做状态隔离，基于类型是比较容易理解的方式，因为类型有明确的归属和可见性。&lt;/p&gt;

&lt;p&gt;这样在 Move 中，智能合约之间的调用变成如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/why-move/move-module-call.png&quot; alt=&quot;move module call&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同组织和机构的程序，通过动态库的方式，组合成同一个应用运行，共享同一个编程语言的内存世界。组织之间不仅可以传递 消息，同时可以传递 引用 ，和 资源 。组织之间的交互规则和协议，只受编程语言的规则约束。(关于 资源 的定义后文中有描述)。&lt;/p&gt;

&lt;p&gt;这个改变同时带来几个方面的变化：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编程语言以及链可以提供一个功能丰富的基础库，提前部署到链上。应用直接依赖复用并不需要在自己的二进制中包含基础库部分。&lt;/li&gt;
  &lt;li&gt;由于不同组织之间的代码在同一个编程语言的内存世界状态里，可以提供更丰富和复杂的组合方式。这个话题在后面会详述。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Move 的这种依赖方式虽然和动态库的模式类似，但它同时利用了链的状态托管的特性，给编程语言带来了一种新的依赖模式。&lt;/p&gt;

&lt;p&gt;这种模式下，链既是智能合约的运行环境，同时也是智能合约程序的二进制仓库。开发者通过依赖将链上的智能合约自由组合起来提供一个新的智能合约程序，并且这种依赖关系是链上可追踪的。&lt;/p&gt;

&lt;p&gt;当然 Move 现在还很早期，这种依赖方式提供的能力尚未充分发挥出来，不过雏形以及出现。可以设想，未来肯定可以出现基于依赖关系的激励机制，以及基于这种激励模式构建出的新的开源生态。后面我们继续谈一谈可“组合性”的问题。&lt;/p&gt;

&lt;h2 id=&quot;智能合约的可组合性&quot;&gt;智能合约的可组合性&lt;/h2&gt;

&lt;p&gt;编程语言模块之间的可组合性是构建编程语言生态的另外一个重要特性。可以说，正因为模块之间有可组合性，才产生依赖关系，而不同的依赖方式也提供了不同的组合能力。&lt;/p&gt;

&lt;p&gt;根据前面对依赖方式的分析，在 Solidity 生态谈论智能合约的可组合性的时候，实际上主要说的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contract&lt;/code&gt; 之间的组合，而不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;library&lt;/code&gt;  之间的组合。而我们前面也说了， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contract&lt;/code&gt; 之间的依赖是一种类似与远程调用的依赖，互相传递的实际上是消息，而不能是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;引用&lt;/code&gt; 或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;资源&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;资源(resource)&lt;/code&gt;  这个词，主要是强调这种类型的变量在程序内不能随意的复制(copy)或者丢弃(drop)，这是线性类型带来的特性，这个概念在编程语言中还不普及。&lt;/p&gt;

&lt;p&gt;线性类型来自于线性逻辑，而线性逻辑本身是为了表达经典逻辑无法表达的资源消耗类的逻辑。比如有“牛奶”，逻辑上可以推导出“奶酪”，但这里没办法表达资源消耗，没办法表达 X 单位的“牛奶”可以得出 Y 单位的“奶酪” 这样的逻辑，所以才有了线性逻辑，编程语言里也有了线性类型。&lt;/p&gt;

&lt;p&gt;编程语言中首先要处理资源就是内存，所以线性类型的一个应用场景就是追踪内存的使用，保证内存资源被正确的回收，比如 Rust。但如果将这个特性普遍推广，我们就可以在程序中模拟和表达任意类型的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;资源&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那为什么组合时能进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;资源&lt;/code&gt; 传递非常重要呢？我们先来理解一下当前的基于 Interface 的组合方式，大多数编程语言，包括 Solidity 都是这样的组合方式。&lt;/p&gt;

&lt;p&gt;我们要将多个模块组合起来，最关键的是约定好调用的函数以及函数的参数和返回值类型，一般叫做函数的“签名”。我们一般用 Interface 来定义这种约束，但具体的实现由各方自己实现。&lt;/p&gt;

&lt;p&gt;比如大家常说的 ERC20 Token，它就是一个 Interface，提供以下方法：&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balanceOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个接口的定义中，有给某个地址转帐的方法，也有查询余额的方法，但没有直接提款（withdraw）的方法。因为在 Solidity 中，Token 是一个服务，而不是一种类型。下面是 Move 中定义的类似的方法：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TokenType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出，Token 是一种类型，可以从账号 withdraw 出来一个 Token 对象。有人要问，这样做有什么意义呢？&lt;/p&gt;

&lt;p&gt;我们可以通过一种比较通俗的类比来比较二者的组合方式的区别。Token 对象类似于生活中的现金，你想去一个商场购买东西，有两种支付方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;商场和银行对接好接口，接入电子支付系统，你支付的时候直接发起请求让银行划账给商场。&lt;/li&gt;
  &lt;li&gt;你从银行取出现金，直接在商场支付。这种情况，商场并不需要提前和银行对接接口，只要接受这种现金类型就行。至于接收现金后，商场是将现金锁在保险柜里，还是继续存到银行中，这个由商场自己解决。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而后一种组合类型，可以称做基于资源类型的组合方式，我们可以把这种在不同组织的合约之间流动的资源叫做“自由状态”。&lt;/p&gt;

&lt;p&gt;基于自由状态的组合方式，更像是物理世界中的组合方式。比如光碟和播放机，各种机器的配件。这种组合方式和基于接口的组合方式也并不冲突。比如多个交易所（swap）想对外提供统一的接口，方便第三方集成，则使用接口的组合方式更合适。&lt;/p&gt;

&lt;p&gt;基于自由状态的组合的关键优势有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以有效的降低基于接口组合的嵌套深度，对这个感兴趣的朋友可以参看以前我一次分享中关于闪电贷的例子。考虑到有的读者对闪电贷背景不清楚，这里就不详述里。&lt;/li&gt;
  &lt;li&gt;可以明确的将资源的定义和基于资源的行为拆分开来，这里有一个典型的例子是灵魂绑定的 NFT。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;灵魂绑定的 NFT 这个概念是 Vitalik 提出的，想用 NFT 来表达一种身份关系，而这种关系不应该是可以转让的，比如毕业证，荣誉证书等。&lt;/p&gt;

&lt;p&gt;而 ETH 上的 NFT 标准，都是一个接口，比如 ERC721 的几个方法：&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ownerOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tokenId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;external&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safeTransferFrom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tokenId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;external&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;payable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果想扩展新的行为，比如绑定，就需要定义新的接口。还会影响旧的方法，比如转让 NFT 的时候，如果 NFT 已经灵魂绑定了，就无法转让，势必带来兼容性问题。更难的是开始允许转让流通，但绑定后就无法流通的场景，比如部分游戏道具。&lt;/p&gt;

&lt;p&gt;但如果我们把 NFT 设想成一个物品，这个物品本身只决定了它如何展示，有哪些属性，至于能否转让，这个应该是上层的封装。&lt;/p&gt;

&lt;p&gt;比如下面是用 Move 定义的 NFT，它是一种类型。&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;creator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;base_meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Metadata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;type_meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们可以把上层封装设想成不同容器，不同的容器有不同的行为。比如 NFT 放在个人展览馆里的时候，是可以拿出来的，但一旦放一些特殊容器中，想要拿出来则需要有其他规则限制，这就实现了“绑定”。&lt;/p&gt;

&lt;p&gt;比如 Starcoin 的 NFT 标准实现了一种灵魂绑定 NFT 的容器叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IdentifierNFT&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;/// IdentifierNFT 中包含了一个 Option 的 NFT，默认是空的，相当于一个可以容纳 NFT 的箱子&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IdentifierNFT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;nft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;/// 用户通过 Accept 方法初始化一个空的 IdentifierNFT 在自己的账号下&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;/// 开发者通过 MintCapability 给 receiver 授予该 nft，将 nft 嵌入到 IdentifierNFT 中&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grant_to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MintCapability&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;/// 开发者也可以通过 BurnCapability 将 `owner` IdentifierNFT 中的 NFT 取出来&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;revoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BurnCapability&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NFTMeta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NFTBody&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个箱子里的 NFT，只有 NFT 的发行方可以授予或者收回，用户自己只能决定是否接受，比如毕业证书，学校可以颁发和收回。当然开发者也可以实现其他规则的容器，但 NFT 标准是统一的。对这个具体实现感兴趣的朋友，可以参看文末链接。&lt;/p&gt;

&lt;p&gt;这段阐述了 Move 基于线性类型带来的一种新的组合方式。当然，只有语言的特性优势并不能自然带来编程语言的生态，还必须有应用场景。我们继续来讨论 Move 语言的应用场景扩展。&lt;/p&gt;

&lt;h2 id=&quot;智能合约的应用场景扩展&quot;&gt;智能合约的应用场景扩展&lt;/h2&gt;

&lt;p&gt;Move 最初作为 Libra 链的智能合约编程语言，设计之处就考虑到了不同的应用场景。当时 Starcoin 正好在设计中，考虑到它的特性正好符合 Starcoin 追求的目标，就将其应用在公链场景里。再后来 Libra 项目搁浅，又孵化出几个公链项目，在几个不同的方向上探索：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MystenLabs 的 Sui 引入了不可变状态，试图在 Move 中实现类似 UTXO 的编程模型。&lt;/li&gt;
  &lt;li&gt;Aptos 在探索 Layer1 上的交易的并行执行，以及高性能。&lt;/li&gt;
  &lt;li&gt;Pontem 试图将 Move 带入 Polkadot 生态。&lt;/li&gt;
  &lt;li&gt;Starcoin 在探索 Layer2 乃至 Layer3 的分层扩展模式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时 Meta（Facebook）的原 Move 团队在尝试将 Move 运行在 Evm 之上，虽然会损失合约之间的传递&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;资源&lt;/code&gt;的特性，但有助于 Move 生态的扩展以及 Move 生态和 Solidity 生态的融合。&lt;/p&gt;

&lt;p&gt;当前 Move 项目已经独立出来，作为一个完全社区化的编程语言。现在面临几个挑战：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何在不同的链的需求之间寻找最大公约数？保证语言的通用性。&lt;/li&gt;
  &lt;li&gt;如何让不同的链实现自己的特殊语言扩展？&lt;/li&gt;
  &lt;li&gt;如何在多个链之间共享基础库和应用生态？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这几个挑战同时也是机遇，它们之间是冲突的，需要有取舍，需要在发展中寻找一种平衡，还没有一种语言做过这种尝试。这种平衡可以保证 Move 有可能探索更多的应用场景，而不仅仅是和区块链绑定。&lt;/p&gt;

&lt;p&gt;这点上，Solidity 通过指令和链交互带来的一个问题是 Solidity&amp;amp;EVM 生态完全和链的绑定了，运行就需要模拟一个链的环境。这限制了 Solidity 拓展到其他场景。&lt;/p&gt;

&lt;p&gt;关于智能合约编程语言的未来，有许多不同的看法，大体上有四种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不需要图灵完备的智能合约语言，Bitcoin 的那种 script 就够用了。没有图灵完备的智能合约，就很难实现通用的仲裁能力，会局限住链的应用场景。这点可以看我以前的一篇文章《开启比特币智能合约的「三把锁」》。&lt;/li&gt;
  &lt;li&gt;不需要专门的智能合约语言，用已有的编程语言就够了，这个观点我们上面已经分析了。&lt;/li&gt;
  &lt;li&gt;需要一种图灵完备的智能合约语言，但应用场景也仅仅在链上，类似于数据库中的存储过程脚本。这是大多数当前智能合约开发者的观点。&lt;/li&gt;
  &lt;li&gt;智能合约编程语言会推广到其他场景，最终变为一种通用的编程语言。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后一种可以称做智能合约语言最大化主义者，我个人持这种观点。理由也很简单，在 Web3 世界里，无论是游戏还是其他应用，如果遇到争议，需要有一种数字化的争议仲裁方案。而区块链和智能合约关键的技术点就是关于状态和计算的证明，当前这个领域摸索出来的仲裁机制，完全可以使用到更通用的场景中去。当用户安装一个应用，担心应用不安全，希望应用能提供状态和计算证明的时候，也就是应用开发必须要选择用智能合约实现应用核心逻辑的时候。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这篇从链上智能合约的实现途径上，以及当前智能合约在依赖和组合性上遇到的难题，用尽可能通俗的语言阐述了 Move 在这个方向上做的尝试，以及基于这些尝试带来的生态构建的可能性。&lt;/p&gt;

&lt;p&gt;考虑到文章也比较长了，很多方面还没表述到，我会基于这个题目写一个系列，这里做个预告：&lt;/p&gt;

&lt;h4 id=&quot;为什么是-move-之生态构建能力&quot;&gt;为什么是 Move 之生态构建能力&lt;/h4&gt;
&lt;p&gt;这是本文。&lt;/p&gt;

&lt;h4 id=&quot;为什么是-move-之智能合约的安全&quot;&gt;为什么是 Move 之智能合约的安全&lt;/h4&gt;

&lt;p&gt;智能合约的安全是一个广泛关注的问题，布道 Move 的文章也喜欢提“安全”这个特性。但如何比较不同的编程语言之间的安全性？有句俗话说，你不能阻止一个人向自己的脚开枪，编程语言是一个工具，开发者用这个工具向自己的脚开枪的时候，编程语言本身能做些什么事情？智能合约让不通组织的程序运行在同一个进程中，最大化了编程语言的作用，但也带来了新的安全挑战。这篇文章将从一个整体的视角去讨论这个问题。&lt;/p&gt;

&lt;h4 id=&quot;为什么是-move-之状态爆炸与分层&quot;&gt;为什么是 Move 之状态爆炸与分层&lt;/h4&gt;

&lt;p&gt;Move 在编程语言内部实现了状态隔离，同时也给这个领域的解决方案提供了更多的可能性。合约可以更自由的处理状态的存储位置，比如将状态存储在用户自己的状态空间，这样更利于实现状态计费，激励用户释放空间。比如是否可以真正实现状态在不同的层之间的迁移，从而将 Layer1 的状态迁移到 Layer2 ，从而在根本上解决状态爆炸问题？这篇文章将探讨一些这个方向的可能性。&lt;/p&gt;

&lt;p&gt;对后续内容感兴趣，可以通过以下方式关注我：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Twitter:  &lt;a href=&quot;https://twitter.com/jolestar&quot;&gt;@jolestar&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;微博：&lt;a href=&quot;https://weibo.com/u/1648815335&quot;&gt;@jolestar&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Telegram channel: &lt;a href=&quot;https://t.me/jolestarblog&quot;&gt;https://t.me/jolestarblog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;相关链接&quot;&gt;相关链接&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/move-language/move&quot;&gt;https://github.com/move-language/move&lt;/a&gt; Move 项目的新仓库&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/MystenLabs/awesome-move&quot;&gt;awesome-move: Code and content from the Move community&lt;/a&gt;  一个 Move 相关项目的资源集合，包括公链以及 Move 实现的库&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://vitalik.ca/general/2022/01/26/soulbound.html&quot;&gt;Soulbound (vitalik.ca)&lt;/a&gt; Vitalik 关于 NFT 灵魂绑定的文章&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://starcoin.org/zh/developer/sips/sip-22/&quot;&gt;SIP22 NFT&lt;/a&gt; Starcoin 的 NFT 标准，包括 IdentifierNFT 的说明&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jolestar.com/bitcoin-smart-contract/&quot;&gt;开启比特币智能合约的「三把锁」 (jolestar.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 15 May 2022 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/why-move-1/</link>
        <guid isPermaLink="true">http://jolestar.com/why-move-1/</guid>
        
        <category>starcoin</category>
        
        <category>move</category>
        
        <category>smart-contract</category>
        
        
      </item>
    
      <item>
        <title>从智能合约的演进看 Move 的架构设计</title>
        <description>&lt;p&gt;&lt;em&gt;本文首发于 &lt;a href=&quot;http://westar.io/blog/libra_move/&quot;&gt;Westar 实验室博客&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;智能合约是区块链领域大家一直比较关注的主题，本文试图从智能合约的演进角度分析 Libra 的 Move 合约要解决的问题，以及其架构设计，也就是回答『 Libra 为什么要重新设计一种编程语言？』这个问题。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;智能合约是什么&quot;&gt;智能合约是什么&lt;/h2&gt;

&lt;p&gt;开始这个题目之前，我们可以先讨论一个比较大一点的话题，到底什么是『智能合约』？其实『智能合约』这个词在业界争议也很大，每个人有每个人的看法。我们为了方便讨论，在当前主题背景下给它做一个限定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;运行在链上的，由用户自定义的程序&lt;/li&gt;
  &lt;li&gt;通过链节点的重复校验以及共识机制，使其具有不依赖于权威方的独立约束力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先它是运行在链上，由用户自定义的程序。如果是在链上直接实现的，哪怕是通过插件的机制，我们这里也不把它叫做智能合约。其次，因为有了链的重复校验以及共识能力，让这种程序具有了约束力。这个约束力不来自于你对某一方的信任，即便是合约的开发者，也要受这套约束机制的约束。&lt;/p&gt;

&lt;p&gt;至于关于『智能合约』的争议点这里不深入讨论，感兴趣的朋友可以看我以前的一篇从『法律合约』角度讨论智能合约的文章 -《&lt;a href=&quot;https://jolestar.com/what-is-the-smart-contract/&quot;&gt;智能合约到底是什么？&lt;/a&gt;》。&lt;/p&gt;

&lt;h2 id=&quot;回顾智能合约的演进&quot;&gt;回顾智能合约的演进&lt;/h2&gt;

&lt;p&gt;为了理解 Libra 的 Move，我们简单回顾一下智能合约的演进过程。毕竟发明一种新的编程语言需要有足够的动机，世界上的编程语言这么多了，为什么又要发明一种新的语言？这种新的语言要解决什么问题？所以我们得从演进的角度看这个问题。对 Bitcoin 和 Ethereum 都非常熟悉的朋友可以直接跳到后面部分。&lt;/p&gt;

&lt;h3 id=&quot;bitcoin-的智能合约&quot;&gt;Bitcoin 的智能合约&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/bitcoin-locking-unlocking-script.png&quot; alt=&quot;Bitcion locking &amp;amp; unlocking script&quot; /&gt;
（图片来源：Mastering Bitcoin 2nd）&lt;/p&gt;

&lt;p&gt;Bitcoin 的智能合约就是给资产上锁和解锁的脚本（Locking &amp;amp; Unlocking Script）。简单的理解就是 Bitcoin 提供了一种智能锁，用户可以根据自己的需求，排列组合，形成自己的锁，用来锁定或者解锁资产。&lt;/p&gt;

&lt;p&gt;那它为什么不直接确定一种锁定和解锁方式，而是弄很脚本让用户自定义呢？主要目的是给链提供一种逻辑扩展性，这样用户可以在不改变链的基础代码的情况下，增加一些功能，做一些实验。同时它是无状态的（Stateless），一把锁只管一份资产，锁与锁之间也不能共享数据。也被设计成图灵不完备的（Turing Incompleteness），避免用户写出太复杂的锁增加链的解锁校验成本。&lt;/p&gt;

&lt;p&gt;因为 Bitcoin 自己定义的应用场景很明确，无论把它理解成密码货币或者密码资产，主要功能就是保存资产，转让资产。这样的设计也满足它的场景需求了。&lt;strong&gt;只要资产转让合约可以通过锁和解锁来表达，那就可以用 Bitcoin 的智能合约实现。&lt;/strong&gt; 但是不是所有的合约都可以通过锁和解锁表达出来？这个还有待证明。设计一套锁和解锁的协议是非常有挑战性的，比如闪电网络的协议。  关于 Bitcoin 上的不同的锁的机制可以参看李画和我的一个访谈文章 -《&lt;a href=&quot;https://jolestar.com/bitcoin-smart-contract/&quot;&gt;开启比特币智能合约的「三把锁」&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;但既然 Bitcoin 提供了这样一种去中心化记账的能力，用户会想我是否可以把它用在其他地方？比如把一份数据的 Hash 作为一个地址，给这个地址转很小一笔资产，这个 Hash 地址就被公示在链上了，就可以提供一种数据的存在证明。但这笔钱是没办法被花费的，因为没有人知道这个 Hash 地址对应的私钥是什么。如果这样的交易多了后，会给 Bitcoin 的链带来很大的压力，因为链要维护所有的未花费交易（UTXO）。&lt;/p&gt;

&lt;p&gt;于是 Bitcoin 开发者就想了一个办法，增加了一个指令 OP_RETURN。用户不需要把自己的数据伪装成地址，直接在脚本中嵌入自己的数据，然后再加上 OP_RETURN，这样链就知道这笔交易在未来不会被花费，仅仅是记录数据在区块中。而有了这套机制后，越来越多的第三方开发者就尝试用 Bitcoin 的网络来发行另外一种资产，这就是大家常说的染色币（Colored Coins）。染色币利用了 Bitcoin 网络的广播交易，在区块中记录数据的能力，发行方只需要运行一些节点接入 Bitcoin 网络，对 OP_RETURN 中的数据进行校验即可，成本比自己独立运行一条链的成本低许多。那再进一步想下，如果脚本中能读取和生成状态，是不是这种校验节点也可以不需要了，可以直接委托给链来校验了？这就诞生了 Ethereum。&lt;/p&gt;

&lt;h3 id=&quot;ethereum-的智能合约&quot;&gt;Ethereum 的智能合约&lt;/h3&gt;

&lt;p&gt;Ethereum 的智能合约是有状态的，图灵完备的。比如看一下社区官网给的一个 Coin 的例子（有简化）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/solidity-coin.png&quot; alt=&quot;solidity coin&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子中，Coin 合约中的 balances 是一个 map，保存用户的地址和余额的映射，转账时减少发送方的余额，增加接收方的余额就行。看起来很简单吧？像是一个单机程序一样，会一点编程语言的人大约就能看明白。但要提供这样的能力，有一些难题需需要解决，而 Ethereum 的这些解决方案都是区块链智能合约领域很重要的创新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图灵完备与停机问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然是图灵完备的语言，那就需要解决停机问题。如果有人写一个死循环合约放到链上，那所有的节点都进入了死循环。并且根据停机问题的证明，没办法直接通过分析程序来判断是否会进入死循环，也就是说没办法提前阻止用户部署这样的合约到链上，只有真正运行的时候才知道是否会死循环。于是 Ethereum 设计了一种 gas 机制，执行每个指令的时候都需要消耗一部分 gas，当 gas 消耗完了后合约会执行失败退出。这是一个非常经典的创新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;合约的状态存储与节点状态的一致性校验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bitcoin 中的脚本是无状态的，它的状态只是 UTXO，每个节点维护一份自己的 UTXO 列表就行。但 Ethereum 的合约是有状态的（就是合约中保存的数据，比如前面例子中每个人的余额），并且可以通过交易变更，那如果这些状态出现了不一致的情况（比如有 bug 或者存储设备错误），节点如何校验？&lt;/p&gt;

&lt;p&gt;为了解决这个问题，Ethereum 设计了一种状态树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/ethereum-block-architecture.png&quot; alt=&quot;ethereum block architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(图片来源:&lt;a href=&quot;https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture&quot;&gt;ethereum stackexchange ethereum-block-architecture&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;它整体的思路是每个合约中的每个外部存储变量，在状态树上都表现为一个节点。一个合约的所有变量生成一个状态树，数的根节点就是 Storage Root，而这个 Storage Root 又通过合约地址映射到 Global Storage Root 上。只要任何一个合约中的任何一个变量有变化，Global Storage Root 就会变化，节点之间就可以通过比较 Global Storage Root 来快速校验数据的一致性。同时它也提供了一种状态证明能力，可以让节点之间信任对方的状态数据，快速同步节点状态，而不是重新通过区块计算一遍。&lt;/p&gt;

&lt;p&gt;关于这个状态树（Merkle Patricia Tree），这里也不细说，有兴趣的可以看看 Ethereum 相关的书或者文章。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;合约的抽象与跨合约调用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然是 Ethereum 提供的 Solidity 是一种完备的编程语言，就有抽象与互相调用的问题。Solidity 中设计了 Interface，这个和其他编程语言中的 Interface 类似。开发者可以先协商定义一种 Interface 作为标准，然后各自实现。合约之间，以及合约和客户端（比如钱包）之间都可以通过 Interface 来调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/erc20.png&quot; alt=&quot;erc20&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例如上面的 ERC20 的 interface，定义了转账，查询余额等标准方法。而 approve 的目的是给第三方授权一个额度，可以从用户账号上扣钱，类似于信用卡的预授权机制。社区开发者如果有新的想法了就提出一个 ERCxxx，其他人可以基于这个 ERCxxx 进行进一步的组合创新。这套机制灵活性很强，Ethereum 上繁荣的 Defi 生态主要就是依赖这套机制演进出来的。&lt;/p&gt;

&lt;h3 id=&quot;ethereum-的问题&quot;&gt;Ethereum 的问题&lt;/h3&gt;

&lt;p&gt;当然，世上没有完美的技术，Ethereum 提供了一些新的能力，同时也带来一些新的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;链上原生资产（Ether）和通过合约定义的资产（ERC 20 Token）之间的抽象和行为不一致&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这点如果写过 Ethereum 合约的人就会很有体会。如果你要写一个合约，同时处理 Ether 和其他 Token，你会发现二者的处理逻辑完全不一样，很难用统一的方式去处理。并且二者的安全性也不一样，Ether 的安全性由链保证，而 Token 的安全依赖于该 Token 的开发者。比如 Ethereum 中的 layer2 方案里，如果同时要支持 Ether 和 Token 也会比较复杂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安全问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ethereum 上爆出了很多安全性事故，虽然很多问题的直接原因是合约开发者的实现不够严谨，但本质上的原因来自于两点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可扩展性与确定性之间的矛盾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Interface 的机制提供了很强大的扩展性，但 Interface 只定义了接口，并无法保证实现遵循接口的要求。比如下面这个例子，是我曾经开发的一个恶搞的 Token:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/foolcoin-transfer.png&quot; alt=&quot;foolcoin transfer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个 Token 的转账方法里面包含一种随机机制，有一定的概率可以转让成功，但也有一定的概率反倒增加自己的 Token。而这种行为被 Interface 的 transfer 掩盖，调用方根本不清楚它的具体实现，从而可能带来安全性问题。&lt;/p&gt;

&lt;p&gt;当然有一种办法是直接实现一种确定逻辑的 Token，不允许用户自定义逻辑，只提供有限的配置项，比如总额，名称等。有的链为了解决 Ethereum 的安全性问题，就是这样做的。但这样用户就无法根据自己的场景进行扩展，比如要实现一个只对某个群体的用户可用的 Token。同时这种扩展性需求是没法穷举的，只能让用户不断尝试演化。这就是可扩展性与确定性之间的矛盾难题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;合约间的调用问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ethereum 上的合约间的调用，是一种动态调用。它实际上构造了一种内部的交易，然后启动了一个新的虚拟机去执行调用。机制上有点像服务器之间的远程调用，而这种调用有可能形成循环调用，从而出现类似并发的情况，即便虚拟机是单线程执行的。比如 A 合约调用 B 合约，而 B 合约又调回 A 合约。于是 A 合约的前一次执行尚未完成，又进行了下一次执行，而第二次的执行无法读取到第一次执行的中间状态。这也就是那次 DAO attack 利用的漏洞。关于这个问题的分析可以参看论文 &lt;a href=&quot;https://arxiv.org/pdf/1702.05511.pdf&quot;&gt;A Concurrent Perspective on Smart Contracts&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;合约状态爆炸&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;合约状态爆炸的主要原因是 Ethereum 虽然设计了 gas 费用机制，避免用户滥用网络。但这个 gas 只针对计算，是一次性收取的，一旦数据写入到合约状态，就永久保留了，用户无需为自己的数据未来的存储承担成本。这样导致用户和开发者都没有动力去清理无用的状态。同时，Ethereum 的同一个合约的所有用户状态都在该合约账号下，热门合约下的数据会膨胀的更厉害。&lt;/p&gt;

&lt;p&gt;Ethereum 开发者尝试实现状态租赁的机制，让用户为自己的状态付 state fees，但所有用户的状态都是保存在合约账号下的，链很难明确状态和用户的关系，更无法区分那些是合约的公共状态，哪些是具体用户的状态，方案设计起来非常复杂，最后还是放弃了，将这个目标放在了 Ethereum 2.0 中。感兴趣的读者可以看看 &lt;a href=&quot;https://github.com/ledgerwatch/eth_state/blob/master/State_Fees_3.pdf&quot;&gt;Ethereum state fees&lt;/a&gt; 的一版方案设计。&lt;/p&gt;

&lt;p&gt;思考一下，上面 Ethereum 遗留的几个问题，如果让你来设计方案，你会如何解决？后面我们来具体分析 Libra 的 Move 是如何解决这些问题的。&lt;/p&gt;

&lt;h2 id=&quot;libra-move&quot;&gt;Libra Move&lt;/h2&gt;

&lt;p&gt;这是我总结的 Move 的几个特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;First-class Resources&lt;/li&gt;
  &lt;li&gt;Abstract by data not behavior，No interface，No dynamic dispatch。&lt;/li&gt;
  &lt;li&gt;Use Data visibility &amp;amp; Limited mutability to protected resource，No inheritance.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First-class Resources 包含两层的含义。一层就是大家常说的一等公民资产。Libra 上，所有的资产都是通过合约实现的，包括 LibraCoin，都共享一套抽象逻辑以及安全机制，地位平等。第二层意思是 Move 中的资产都是通过 Resource 定义的一种类型，可以直接在数据结构中引用。&lt;/p&gt;

&lt;p&gt;第二条简单的理解就是它抛弃了 interface 的机制。但如果没有了 interface，我们怎么定义协议和标准呢？具体它是怎么通过数据来抽象的，这个后面细说。&lt;/p&gt;

&lt;p&gt;第三条是说，既然资产是一种数据类型，并不能隐藏到合约内部，通过什么方式保护它？比如阻止用户直接 new 出某种资产？&lt;/p&gt;

&lt;p&gt;在了解 Move 如何解决上面的问题之前，我们先了解一下 Move 中的基本概念。&lt;/p&gt;

&lt;h3 id=&quot;move-中的基本概念&quot;&gt;Move 中的基本概念&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Module，Resource|Struct，Function&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Module 和其他语言中的模块，比如 Rust 中的 mod，Ethereum Solidity 中的 Contract 类似，封装了一系列数据结构以及方法。Resource|Struct 和其他语言中的 Struct 一样，都是用来定义新的数据结构类型。Resourc 和 |Struct 的区别是 Resource 要存储到外部状态中，并且是不可复制的。Function 和其他语言中的 Function 没有太大区别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Copy，Move&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是 Move 借鉴 Rust 的生命周期机制引入的概念，Move 中的所有变量使用的时候都需要确定是要 Move 还是 Copy，一旦被 Move，该变量就不可再被使用。而 Resource 只能被 Move 不能被 Copy，当然 Resource 的引用（Reference）是可以 Copy 的。这样编译器就可以向追踪内存的使用一样，追踪资产的转移和变化，避免资产凭空消失或者产生。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Builtin 方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Move 提供了一些内置的方法来和链的状态交互。Solidity 中，开发者几乎不需要关心合约的状态是怎么存储和持久化的，几乎对开发者透明。但 Libra 中，开发者要显式的调用方法去外部获取状态。这样强迫开发者在写合约的时候，把状态明确拆分到了具体的账号下，才能实现状态租赁以及淘汰机制。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;borrow_global&lt;T&gt;(address)/borrow_global_mut&lt;T&gt;(address)  从 address 账号下获取类型为 T 的 Resource 引用。&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
  &lt;li&gt;move_from&lt;T&gt;(address)  将 Resource T 从 address 账号下 move 出来。&lt;/T&gt;&lt;/li&gt;
  &lt;li&gt;move_to_sender&lt;T&gt;() 将 Resource T 存到交易的发送方账号下。&lt;/T&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面例子中的 T 都必须是当前 Module 定义的类型，一个 Module 中不能直接获取其他 Module 定义的类型。下面我们通过一些具体的例子来理解 Move 的机制。&lt;/p&gt;

&lt;h3 id=&quot;一个的例子&quot;&gt;一个的例子&lt;/h3&gt;

&lt;p&gt;这个例子是 LibraCoin 的定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/libra-coin.png&quot; alt=&quot;libra-coin&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如上图的 LibraCoin module，定义了一种 resource 类型 T，代表一种 Coin，内部只包含一个数字，代表它的值。而在 LibraAccount 以及 HashTimeLock 中，直接引用 LibraCoin.T 作为自己类型的一个字段。从这里就可以看出 Move 和 Solidity 之间的差异。Solidity 中，一种 Coin 就是一个合约，并不存在某种 Coin 的数据类型。那这样定义后，Coin 如何定义自己的行为呢？用户怎么用呢？继续看下面的例子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/libra-coin2.png&quot; alt=&quot;libra coin2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LibraCoin module 中定义了 LibraCoin.T 的最基本的方法，比如获取它的 value，切分，合并等。这些方法都是和 Coin 类型相关的最基本的操作，并不包含更高级的，比如给某个账号转账。LibraCoin 中的 deposit 和 withdraw 方法，并不是针对账号，而是正对 LibraCoin.T 类型的引用。在 Move 中，某个 Resource 的内部结构只有定义该 Resource 的 module 内可见，外部 module 只能将某个 Resource 当一个整体对待，无法直接行 split，join 这样的操作。&lt;/p&gt;

&lt;p&gt;那合约中定义的 Coin 如何发行呢？既然它是一种类型，如何控制  Coin 发行的权限？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/libra-coin3.png&quot; alt=&quot;libra coin3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的例子中有一个 mint 方法，进行铸币，方法最后实际上就是直接 new 了一个 LibraCoin.T，并填入一个 数字。而这个方法有一个参数，capability，它代表一种铸币的权限。而 MintCapability 如何产生呢？可以看 initialize 方法，这个是在创世块初始化的时候，由一个特殊账号创建，并持有。只要账号下拥有 MintCapability ，即可通过 mint_with_default_capability 方法来铸币。&lt;/p&gt;

&lt;p&gt;继续来看看如何 LibraCoin 如何实现高级的转账:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/libra-account.png&quot; alt=&quot;LibraAccount&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LibraAccount 的 T 中的 balance 字段是 LibraCoin.T  类型的，所以针对账号的转账，支付都是在 LibraAccount 中定义的，LibraAccount 调用 LibraCoin 的方法操作自己的 balance 字段，从而实现转账。LibraCoin 本身不关心高级的转账逻辑。这样一层一层组合起来，就构造出高级的功能了。&lt;/p&gt;

&lt;p&gt;继续看一下 HashTimeLock 的一种实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/hash-time-lock.png&quot; alt=&quot;HashTimeLock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例子中的 lock 方法，将资产封装到 HashTimeLock.T 中，并和 hash ，time 绑定在一起。unlock 的时候校验 hash 以及 time，如果正确则将 HashTimeLock.T 解开，返回其中封装的资产。而 lock 的时候的资产从哪里来，解锁后的资产又存到哪里去，这个 HashTimeLock 合约不关心，可以由其他合约定义，或者直接在交易的 main 脚本中编写，如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/hash-time-lock-script.png&quot; alt=&quot;HashTimeLock script&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个脚本中，资产是从 LibraAccount 中取出，之后又充到 LibraAccount 中。这个可以由每个交易自己定义。&lt;/p&gt;

&lt;h3 id=&quot;不支持-interface-如何定义标准&quot;&gt;不支持 Interface 如何定义标准&lt;/h3&gt;

&lt;p&gt;前面的例子可以看出 Move 如何通过组装以及可见性机制来组合出高级功能，在不提供动态分发的机制下，也保证了足够的扩展。但如果没有 Interface 这样的机制，如何定义像 Ethereum 中的 ERC20 这样的标准？不同的 Token 的实现都不一样，上层的 Defi 协议如何定义？&lt;/p&gt;

&lt;p&gt;有一次我和 Move 的开发者交流这个问题，他说了一句话给我印象很深刻。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When code is law, interfaces are a crime. – tnowacki&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在代码即法律的世界，接口就是犯罪。因为接口只定义了行为，却不关心实现。而对资产进行编码的时候，用户更希望资产本身相关的操作是确定的。&lt;/p&gt;

&lt;p&gt;他举了一个 Token 的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/token.png&quot; alt=&quot;Token&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子通过泛型定义了一种带标签的 Coin，任何人都可以基于这个 Coin 来定义一种新的 Coin。Coin 的基本操作都是确定的，但 Coin 的发行者可以在上层继续封装，衍生出不一样的特性。这样的机制下，既保证了行为的确定性，也具有足够的扩展性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/move-vs-solidity.png&quot; alt=&quot;Move vs Solidity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打一个比喻，Solidity 中的 Token 实现类似于记录了一个账本，而 Move 则类似于把资产封装起来。大家去租东西交押金的时候，会遇到两种营业员。第一种把营业员把钱汇总到一起，然后在账本上记录一下。第二种营业员则把钱用一个夹子夹起来，记个名字。第一种退钱的时候，营业员需要修改账本，然后把押金从汇总的钱中分出来，给客户。而后一种则直接找到对应的押金夹子直接给客户。前一种像 Solidity ，后一种像 Move。箱子的好处是可以箱子套箱子，很容易组合出更复杂的箱子，账本要组合就只能通过账本之间互相引用记录来实现。&lt;/p&gt;

&lt;h3 id=&quot;move-的状态存储&quot;&gt;Move 的状态存储&lt;/h3&gt;

&lt;p&gt;前面介绍了一下 Move 语言本身的特性，而合约的编程语言和它的状态存储机制密不可分，下面我们再探讨一下 Libra 在状态存储机制上的改进。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/libra-global-state.png&quot; alt=&quot;libra-global-state&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面这个公式说明了哪些数据属于 Libra 的 GlobalState。所有账号和账号状态之间的映射。而账号的状态包括用户部署的合约（Module），以及用户通过合约生成的 Resource。这点上和 Ethereum 的关键区别是每个用户的所有状态都在其的账号路径下，而不是散落在各个合约里。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/libra-global-state2.png&quot; alt=&quot;libra-global-state2&quot; /&gt;  (图片来源 libra 白皮书)&lt;/p&gt;

&lt;p&gt;上图中的， Sparse Merkle Tree 相当于 Ethereum 中的 Merkle Patricia Tree，二者作用一样，只是算法实现上有差异。而 Merkle Tree Accumulator 则是 Libra 新增加的。Ethereum 中，每个区块生成一个全局状态树的根，打包在区块头里。而 Libra 中的做法是每个交易都生成一个状态树的根，然后把这些根和交易信息关联，再用累加器累加起来，生成一个累加器的根，区块的头中包含累加器的根就可以了。这个累加器是全局的，并不是某个区块的。&lt;/p&gt;

&lt;p&gt;可以先看看它的累加器（Accumulator）的实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/merkle-tree-accumulator.png&quot; alt=&quot;Merkle tree accumulator&quot; /&gt;&lt;/p&gt;

&lt;p&gt;累加器顾名思义其实就是把数据累加起来形成一个结果，但还要能提供这个结果包含某个数据的证明。累加器也有纯密码学的实现（如 RSA Accumulator），但计算效率还很难达到应用的要求，安全证明也比较难，所以通过 Merkle tree 来实现累加器是一种更现实的做法。&lt;/p&gt;

&lt;p&gt;Merkle tree 来实现累加器其实就是要提供一种给 Merkle tree 动态增加节点的算法。Merkle tree 本身是一种二叉树，如果叶子节点是确定的，树的高度也就是确定的，计算根节点的值比较容易。但累加器的叶子节点要动态增长的，树的高度也是动态增长的。如上图所示，左边的两颗子树是已经 frozen 的，它的叶节点的值对后面的计算已经没用了，只需要 frozen 的根节点参与计算即可。整个树逐渐增长，逐渐从左到右 frozen。这种算法业界讨论的也挺早了，比如 Bitcion 社区讨论的 Merkle Mountain Ranges 算法。由于篇幅所限，这里不仔细分析它的算法。这种全局累加器的最大作用是提供全局的交易执行存在证明。Ethereum 和 Bitcion 上要证明一个交易发生过，只能先证明改交易被打包在某个区块了，再证明该区块确实在链上，而有了全局累加器可以提供直接的证明。&lt;/p&gt;

&lt;p&gt;再来看看它的 Sparse Merkle tree 实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libra-move/sparse-merkle-tree.png&quot; alt=&quot;sparse-merkle-tree&quot; /&gt;
(图片来源 libra 白皮书)&lt;/p&gt;

&lt;p&gt;Ethereum 用 Merkle Tree 来存状态，提供状态证明，遇到的第一个问题就是 Merkle Tree 的高度太高，计算和存储成本高，生成的证明也很大。于是它做了一个优化，相当于把二叉树给变成十六叉树了。而 Libra 的思路类似，也是给路径做压缩。比如上图中的 1 是一棵完整的二叉树，2 优化掉了空的子树，3 在不产生分歧的情况下，优化掉了中间的节点，缩短了路径。可以说和 Ethereum 的 Merkle Patricia Tree 殊途同归，但 Sparse Merkle tree 的一个独特优点是可以提供不存在证明。更详细的算法实现分析可以看 @lerencao 的文章 &lt;a href=&quot;http://westar.io/blog/jellyfish-merkle-tree-in-libra/&quot;&gt;Jellyfish Merkle Tree in Libra Blockchain&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;### Move 的现状&lt;/p&gt;

&lt;p&gt;最后简单说一下 Move 的现状。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上面的部分例子是 Move IR（中间语言），部分是  Move source lang。Move source lang 是对最终开发者的编程语言，但现在还没正式用在 Libra 中，Libra 中用的还是 IR。&lt;/li&gt;
  &lt;li&gt;泛型的支持尚未最终完成，上面的部分例子还不能直接运行。&lt;/li&gt;
  &lt;li&gt;Account 状态现在整个是打包成一个大的二进制，尚未像 Ethereum 那样拆分成两层的 tree。&lt;/li&gt;
  &lt;li&gt;集合类型支持上不完备，比如 Map 的支持等。&lt;/li&gt;
  &lt;li&gt;空间租赁机制只是理论上设计，尚未实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;总结一下 Move 和 Libra 的主要改进点以及意义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FirstClass Resource，让资产不仅可编程，并且可以映射成程序中的类型，提供了一种新的编程的模型。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同一个用户的所有状态都在用户路径下。这个让对状态空间租赁以及用户状态淘汰提供了技术上的可能。（注:用户状态被淘汰后，可以通过付费再重新存回来）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;状态存储机制上的改进与优化，给一个交易都关联一个全局状态，可以提供交易的全局证明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Libra 的这些设计在二层（layer2）机制也很有潜力，主要来源于 1 它统一的资产编程模型，比较容易设计通用的 layer2 方案。2 用户状态的拆分，方便状态在链上链下之间迁移。3. 全局的证明机制，方便二层仲裁。具体如何利用这些特性设计 layer2 方案，我会在未来的文章中和大家探讨。&lt;/p&gt;

&lt;p&gt;最后回答一下开篇的问题，上面这些创新点确实足够支撑 Move 作为一种新的编程语言立足。技术的发展就是在不断引入通过创新来解决遗留问题，但同时又带来新的问题，然后再触发新的创新这样一波一波推进的。&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/libra-move/</link>
        <guid isPermaLink="true">http://jolestar.com/libra-move/</guid>
        
        <category>libra</category>
        
        <category>move</category>
        
        <category>smart-contract</category>
        
        
      </item>
    
      <item>
        <title>开启比特币智能合约的「三把锁」</title>
        <description>&lt;p&gt;本文首发于币信研究院公众号，是李画和我的一个访谈文章，探讨比特币的智能合约。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;受访者：王渊命（微博：@jolestar）&lt;/em&gt;
&lt;em&gt;采访 &amp;amp; 撰文：李画（币信研究院特约研究员）&lt;/em&gt;
本文约5000字，阅读全文需约10分钟。&lt;/p&gt;

&lt;p&gt;随着新的指令和算法的引入，比特币的多签功能正在变得强大。多签不仅是指多个人共同签名，保管一笔比特币资产；它还可以是多个条件「共同签名」，通过这些条件锁定和解锁比特币。&lt;/p&gt;

&lt;p&gt;用条件决定资产的使用，其实就是合约的功能。当这个合约可以被代码表达并无需信任地自动执行时，我们称其为智能合约。因此前比特币核心主管维护人员Gavin Andresen说：比特币的多签功能已经可以完成以太坊上大部分有用的功能。&lt;/p&gt;

&lt;p&gt;那么，比特币是如何实现智能合约的？比特币与以太坊的智能合约又有何区别？我们采访了对区块链和智能合约有着深刻认知的技术写作者王渊命。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/bitcoin-smart-contract/smart-contract.jpeg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;一比特币是否需要智能合约&quot;&gt;一、比特币是否需要智能合约&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Q：比特币需要智能合约吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：需要。智能合约能够为比特币系统带来逻辑可扩展性，在不改变现有基础设施、基础架构的情况下，为系统增加新的功能，从而增强系统的能力。扩展性不只是指TPS、容量和存储等方面。&lt;/p&gt;

&lt;p&gt;智能合约的另一个作用是它能实现具有约束力的合同功能。它是一个定义各方权利和义务关系的协议，只不过是数字化的，且它的执行机制不依赖于现有的法律体系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：比特币作为一种加密货币，为什么需要合同功能？简单交易它不就可以吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：并没有所谓的简单交易，你为什么给我转账？无论是购物，或者是发工资或其他，背后其实都依赖于一个合同。在现实生活中，这个合同的执行是依赖于司法体系的，一方违约，另外一方可以起诉。只有货币而没有司法体系的约束，是没办法完成任何交易的。&lt;/p&gt;

&lt;p&gt;那么在全球化的加密货币世界里，该如何构建这种合同的约束力？依赖于智能合约。智能合约将规则/法律通过代码表达并执行，用代码构建出一套约束力体系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：比特币需要DeFi吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：广义来说，所有的加密货币都属于 DeFi 的应用领域，因为 DeFi 的第一步是有货币。有了货币后，可以围绕货币定义怎么跟其它资产或者货币交换，如何借贷等等，加密货币里的金融相对法币体系的金融还比较早期，可探索的路还很长。&lt;/p&gt;

&lt;h3 id=&quot;二比特币如何实现智能合约&quot;&gt;二、比特币如何实现智能合约&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Q：为什么说比特币系统是支持智能合约的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：合约就是当我跟你做一个交易时，它能保证这个交易达成，也就是说它能表达某种条件，当条件满足时我才给你付款。能把这个条件表达出来，就可以认为它有智能合约表达能力。比特币的脚本（Script）是有智能合约表达能力的，可以把比特币的脚本理解成是一种智能合约。&lt;/p&gt;

&lt;p&gt;那为什么比特币要通过脚本而不是把功能固化在链上？因为如果固化在链上，当用户/开发者需要某个功能时，就需要比特币开发团队去实现，然后再发布，然后推动整个链的升级，但区块链升级是个复杂的事情，弄不好就分叉了。&lt;/p&gt;

&lt;p&gt;所以比特币只提供最基础的一些素材，相当于给你提供面粉，但菜怎么做留给你自己，你可以利用这些素材，根据自己的场景组合出新的东西，不需要依赖于主链的升级。这也就是我前边讲过的通过智能合约来实现逻辑可扩展性。未来是不确定的，智能合约可以看成是一种应对不确定性的策略。&lt;/p&gt;

&lt;p&gt;上边是比特币系统本身对智能合约的支持，它是通过脚本实现的；还有另一类支持/实现智能合约的方式，就是通过比特币系统的侧链，在侧链上实现智能合约的方法跟在以太坊上类似。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：比特币系统是如何通过脚本实现智能合约的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：以太坊上的智能合约是直接用代码表达清楚的，什么条件下执行 A，什么条件下执行 B 等等，比特币上的智能合约不像以太坊那样直白。&lt;/p&gt;

&lt;p&gt;比特币上所有的智能合约都要被转换成加锁、解锁的机制来实现，也就是说在脚本中，通过「key」或者是「哈希条件」把资产锁定，再加上一个「时间锁」（TimeLock）。无论是闪电网络还是Arwen协议，都是这样的机制，比特币将会推出的Schnoor签名之类的，也都是为了更好地去表达这个机制。&lt;/p&gt;

&lt;p&gt;因此，实现比特币智能合约的核心就是怎么去加锁和解锁资产。&lt;/p&gt;

&lt;p&gt;如果合约中所有的条件都能转换成key、哈希条件、时间锁这三者来加锁和解锁，那么这个合约就可以用比特币系统实现。我把这三者分别称为签名锁，哈希锁，时间锁，比特币智能合约基本就是用这「三把锁」来实现的。&lt;/p&gt;

&lt;p&gt;比如你从我这儿买一个音乐，这个音乐通过密码访问，那么在交易合约中，我把音乐的访问密码也变成其中的一个key，如果要达成交易，这个key必须让你知道；而一旦你知道（你拿到音乐），钱就支付给我了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：哈希条件和key有什么不同？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：你可以理解成一个东西，它们的作用是一样的。哈希条件是我知道一个value，把value哈希之后得到一个哈希结果。那么在合约中，就是设置一个条件，谁能在写交易的时候把这个哈希结果打进来，这钱就归谁。只要我有这个value，就有哈希结果，也可以理解成有一个key。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：简单而言，可不可以认为比特币的智能合约是通过多签加上时间锁来实现的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：可以，前边讲过用key、哈希条件、时间锁实现智能合约，哈希条件也可以当作多重签名中的一个key来看待；时间锁则是一个关于区块高度的条件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：时间锁在实现智能合约中的重要性是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：时间锁很重要，如果没有时间约束的话，很多协议是没法实现的。正是因为现在有了哈希条件、时间锁，闪电网络这种合约才能跑起来。&lt;/p&gt;

&lt;p&gt;比如说闪电网络，我们两个人共同出钱，把钱冻结到一个共管的账号里，然后在链下互相支付，当要去结算时一方不合作了怎么办？假设我们吵架了，你的钱你不要了，但我的钱我也拿不到。有了时间锁就好处理了，我设一个超时时间，过了超时时间钱就是我的，我就可以拿走了。&lt;/p&gt;

&lt;h3 id=&quot;三比特币与以太坊智能合约的差别&quot;&gt;三、比特币与以太坊智能合约的差别&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Q：对应于比特币用脚本实现智能合约，以太坊是用什么实现智能合约的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：以太坊有一个智能合约语言。其实比特币的脚本也可以理解成一种语言，只不过比较简单；比特币脚本执行也可以理解成有一个虚拟机，只不过虚拟机的实现比较简单。既然都是虚拟机执行指令，那么以太坊的改变在哪里？&lt;/p&gt;

&lt;p&gt;我总结以太坊带来的主要改变有三点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;以太坊虚拟机指令的表达能力更强。简单理解的话，可以认为以太坊提供的指令更低级，用低级的指令组合成高级指令，而比特币是直接提供高级指令，其指令是有限的。另外，以太坊支持跳转等指令，能表达出循环等逻辑，也就是大家常说的图灵完备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以太坊引入了 gas 机制。在以太坊上可以随意写合约逻辑，gas机制保证最后执行的时候有一个上限限制，这除了解决停机问题外，还能限制浪费资源，让脚本的执行成本跟付出的费用间有个关系。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以太坊上的合约有状态，而比特币上的合约不能有自己的状态。这代表着：第一，比特币上的合约是不能自己生成自己的状态的，比如说在这次脚本里输出一个东西，在下次脚本中使用是不行的，比特币的脚本都是一次性的，只对这个交易起作用；第二，比特币上的脚本是不能直接读取链上已有的状态的，比如时间锁依赖链上的区块高度，需要特殊指令支持，嵌入到脚本里的其他状态（通过 op_return 指令实现）更无法读取。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Q：图灵完备会带来什么差别？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：其实以太坊也不是说真图灵完备，因为它有gas的限制，不可能用太复杂的逻辑。&lt;/p&gt;

&lt;p&gt;图灵完备的好处是它的扩展能力更强，表达能力更强。因此以太坊提供的实验的自由度要远大于比特币，这也是以太坊上各种实验项目多的原因。&lt;/p&gt;

&lt;p&gt;比特币是一种保守策略。我就这么多指令，我在别的地方先实验，实验好了，觉得需要支持这个指令，就增加这个指令。比如说为了支持原子交换以及支付通道，增加了哈希时间锁定协议，可以锁定一个时间段。&lt;/p&gt;

&lt;p&gt;比特币为什么不扩充那么多指令？因为不同指令的资源消耗是不一样的，如果表达很复杂的脚本，执行这个交易的成本就会很高，会消耗资源、影响整个网络。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：合约状态会带来什么差别？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：比特币的状态全是在链下生成的，就是说生成交易的时候就要把这个状态写好，链上只承载交易的数据，其它额外的数据写不进去。&lt;/p&gt;

&lt;p&gt;比如你很难在比特币上发自己的币。在比特币上发的币都是染色币，染色币是在脚本里嵌入一些自己的数据结构，但脚本不能读嵌入的这个数据结构，所以也不能通过脚本对这个数据结构做验证，需要再做一个网络校验，看写进去的这个数据是不是合法的。&lt;/p&gt;

&lt;p&gt;所有的染色币都是基于这个机制实现的，它不是像以太坊那样直接发一个token，然后通过合约来校验。&lt;/p&gt;

&lt;p&gt;比特币之所以采用这种设计，本质在于它是不欢迎其他的数据写上去的，因为对比特币网络来说，承载额外的数据是有成本的，这种数据还得永久保存，而用户只付费一次。所以比特币不提供自定义状态的存储，这不是它的路线，通过 op_return 嵌入自定义数据可以理解为一种 hack 行为，并不是比特币提供 op_return  的本来目标。&lt;/p&gt;

&lt;p&gt;其实这能够看出比特币和以太坊在设计思路上的区别：你可以把比特币理解成一个中立的银行，它只提供资产加锁、解锁的机制，谁有钥匙资产归谁，它对其他的条件都不关心；并且每一笔资产都是独立的锁，它也不关心资产之间的关系。比特币的智能合约并不是一段代码，而是一系列操作锁的协议。&lt;/p&gt;

&lt;p&gt;而以太坊的的设计思路是任何合约都可以表现为一系列的交易，后面的交易和前置交易的状态是有关联的，所以它提供一种通用的追踪和更新历史状态的机制，而更新状态的逻辑和条件就由用户自己去创造。以太坊黄皮书里的世界状态的公式很好的表达了这种思路。&lt;/p&gt;

&lt;p&gt;这两种思路其实各有优劣，和设计者的目标以及对世界的抽象有关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：比特币和以太坊的智能合约还有其他不同吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：UTXO模型（未花费交易输出）与Account模型（账户）的不同，也会给两者智能合约的实现带来差异。&lt;/p&gt;

&lt;p&gt;在 UTXO模型中，每一笔钱都有一个标记，使用的时候需要明确知道使用的是哪一笔钱；Account模型则相当于把用户所有的UTXO合并成一个大的UTXO，使用的是这个默认的UTXO。这带来几点不同：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在Account模型下写合约比较简单，只需要说转多少钱，不需要指明转的是哪一笔钱；&lt;/li&gt;
  &lt;li&gt;Account模型可以提前对未来的收益进行约束，也就说这笔钱还没到合约账户，但可以部署合约去约束它该怎么花；&lt;/li&gt;
  &lt;li&gt;由于Account模型相当于合并 UTXO，所以转账时不能直接设置解锁条件，必须先部署一个合约。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，UTXO模型和 Account 模型都是在演化的，有一些项目会对它们做出改变，有机会我会写文章详细分析。&lt;/p&gt;

&lt;h3 id=&quot;四比特币智能合约案例&quot;&gt;四、比特币智能合约案例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Q：怎么理解闪电网络本身就是一种智能合约？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：你可以说闪电网络是一个协议，也可以说它是比特币上的一种智能合约。闪电网络的合约主要解决两个人如何共同锁钱，以及如果一方作弊、不合作等等情况下怎么办的问题，它是通过前边说的三把锁来实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：在闪电网络上实现智能合约又是怎样的一个过程？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：闪电网络实际上是两个人之间的支付通道，现在只支持互相转账。我们尝试在支付通道之上嵌入了一个虚拟机，就可以执行比较完备的智能合约，比如游戏。（注：在闪电网络上实现的智能合约：https://github.com/westarlabs/thor）&lt;/p&gt;

&lt;p&gt;通道双方可以压一笔 BTC，然后去玩游戏，赢的一方得BTC；如果玩的有分歧，可通过仲裁系统去仲裁。仲裁系统相当于一个法院，可以是一个侧链，或是一个双方信任的机构运行的节点，或者是仲裁者市场等等。仲裁系统保留了双方的解锁钥匙（哈希的 value），它仲裁之后把钥匙给赢的一方。&lt;/p&gt;

&lt;p&gt;由于闪电网络的资产是定向的，所以仲裁者只能决定哪个用户得到BTC，但自己不能拿走用户的 BTC，即便是有联合作弊的可能，但作弊成本要比托管模式高。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：通过闪电网络实现智能合约，与通过类似Liquid的侧链实现智能合约，有什么不同？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A：闪电网络上的智能合约是通道双方的链下节点执行的，互相校验，产生分歧时需要有一个仲裁系统来仲裁。而侧链本身就有共识机制，有多个节点来执行和校验合约，所以两者在执行机制上是不一样的。&lt;/p&gt;

&lt;p&gt;在侧链实现智能合约的方式与在以太坊上实现智能合约的方式类似，但当它与主链协同的时候，需要通过比特币的加锁、解锁的机制。&lt;/p&gt;

&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;

&lt;p&gt;作为加密货币，比特币似乎有能力为DeFi的发展提供一个更好的空间，因为它凝聚了最多的共识，也承载着最高的价值和流动性，它是最受信任的加密资产。&lt;/p&gt;

&lt;p&gt;那么作为一种系统，比特币是否支持DeFi的实施？在本文中我们探讨了比特币智能合约的实现机制，并把它与以太坊智能合约进行了一些比较。比特币上的DeFi不仅是可能的，而且会随着多签功能的强大变得更加完备。&lt;/p&gt;

&lt;p&gt;也许我们可以期待以比特币为核心元素的去中心化金融服务的到来。&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/bitcoin-smart-contract/</link>
        <guid isPermaLink="true">http://jolestar.com/bitcoin-smart-contract/</guid>
        
        <category>bitcoin</category>
        
        <category>smart-contract</category>
        
        
      </item>
    
      <item>
        <title>智能合约到底是什么？</title>
        <description>&lt;p&gt;区块链的『智能合约』是一个容易引起争议的概念，一次 Vitalik 也说后悔用智能合约（smart contract）这个名字了，不如当初叫 “persistent scripts”，大约是为这个概念吵累了。有人也问这玩意就一是一段程序脚本，哪里智能了？但如果这样说，大约现在命名为『智能』的东西没有一个配得上吧，智能手机大约可以叫做可以自由安装软件的手机？何况英文的 smart 和 intelligent 在中文中都翻译成『智能』，这更是容易引起误解。&lt;/p&gt;

&lt;p&gt;所以那次争论中，也有人建议叫做 “stored procedures”，就是数据库的存储过程。如果把区块链看做一个分布式数据库的话，从技术实现上来看，智能合约确实很像数据库存储过程。使用一种新的编程语言也不是更本区别，如果使用更通用的 VM，可以和其他的程序使用完全一样的编程语言。另外大家常说的确定性（deterministic），实际上也是图灵机本身具备的特性，只要不引入随机机制，也很难写出不 deterministic 的程序。那为什么新造出个词汇呢？套用一句俗话，我们在谈论『智能合约』的时候，到底指的是什么？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如果从技术角度看不出太大区别，那我们再从法律『合约』的角度看看。按照维基百科的定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Contract:  A &lt;strong&gt;contract&lt;/strong&gt; is a legally-binding agreement which recognises and governs the rights and duties of the parties to the agreement.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;合约是定义了各方权利和义务的，具有&lt;strong&gt;法律约束力&lt;/strong&gt;的协议。也就是说，合约的表现形式实际上不重要，可以是文本的，也可以是口头的，关键是要具有法律约束力。&lt;/p&gt;

&lt;p&gt;那我们套用到『智能合约』上，也可以说智能合约的表现形态也不是关键，关键也在于『约束力』。这里我们给出一个定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;智能合约就是定义各方权利和义务的，具有『约束力』的计算机程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那计算机程序的『约束力』如何产生？&lt;/p&gt;

&lt;h3 id=&quot;智能合约的约束力&quot;&gt;智能合约的约束力&lt;/h3&gt;

&lt;p&gt;分析智能合约的约束力之前，我们先来看看法律合约的约束力。法律约束力来自于两方面，一方面是签订合约的参与方有明确的合约的意向表达，比如酒桌上吹牛的话就很难作为合约，合约要和日常的谈话和文本有明确区别，这也是书面合同在这方面更容易减少误解的原因。另外一方面是公权力提供了这样一套司法执行体系，当合约不能正常履行的时候，可以寻求公权力的裁决执行。&lt;/p&gt;

&lt;p&gt;如果说一个国家的司法体系相当于一个通过自然语言定义规则的操作系统，合约就是在这个操作系统上用自然语言写的程序。自然语言的解释执行当然得人脑来做，但由于自然语言的不严谨，人与人的差异，如何保证执行的结果的确定性？如何防止执行者作弊？这两个难题是司法体系千百年来一直探索的难题。&lt;/p&gt;

&lt;p&gt;切换到智能合约上，由于图灵机的特性，程序执行结果的确定性容易保证，关键难题就是如何防作弊了，怎么证明程序执行出的结果没有被篡改？&lt;/p&gt;

&lt;p&gt;程序执行结果的可信性，取决于控制程序执行硬件的组织或者个人的可信性，当前软件系统，比如银行或者互联网应用，用户只能以信任组织的方式来信任程序运行结果，也就是说约束力是单方的，最终用户受到程序约束，但服务提供方几乎不受程序约束。用户如果对结果有异议，只能诉诸其他手段，比如司法，或者如前段时间某交易所用户去公司门口拉横幅抗议。&lt;/p&gt;

&lt;p&gt;那如果程序可以在不同组织或个人掌握的硬件上重复验证，是不是就可以去除这种信任依赖？同时实现对双方的约束？这个在司法体系中也是如此，比如一审，二审，终审等机制，只是司法体系的执行成本太高了，有争议后才重复验证，次数也受限。但计算机程序这点上成本就低很多，所以可以大规模重复验证。&lt;/p&gt;

&lt;p&gt;如果只有验证能力，实际上并不能产生约束力，还需要有强制执行能力。如果双方争议的标的可以直接由程序操作，也就可以实现验证并执行。这点上，区块链通过定义数字化的资产以及经济体系，来保证执行能力。&lt;/p&gt;

&lt;h3 id=&quot;重复验证的瓶颈&quot;&gt;重复验证的瓶颈&lt;/h3&gt;

&lt;p&gt;计算机重复验证的成本虽然比人肉低许多，但如果每个交易都需要重复验证执行，成本就高了，这就是大家常说的区块链的 TPS (每秒交易数) 问题。那法院执行效率这么低，为什么没有成现实社会交易的瓶颈？区块链现在的做法相当于法院掌握了所有人的资产以及合约执行细节，每次合约执行都通过法院进行，当然会成为瓶颈。&lt;/p&gt;

&lt;p&gt;而现实中的情况是大多数合约并不产生分歧或者争议，所以也不需要法院来裁决，法院也无需知道细节，只有产生争议时，才需要法院裁决，这时候双方提交相关证据即可。那这套机制能不能搬到链上来呢？这就是区块链二层（Layer2）网络试图要实现的目标。那关键问题就是如果没有了链上的重复验证，链下的合约约束力如何产生？&lt;/p&gt;

&lt;p&gt;以太坊社区将”反事实”概念引入区块链，提出了反事实状态通道（Counterfactual state channel），试图总结出一种通用的区块链二层设计原则。这里的”反事实”和法律体系中的”反事实”含义类似。法律合约本身的约束力主要来自于这种反事实推理，如果合约一方违反合约，另外一方则可以通过司法机构来强制执行，交易双方最佳的策略是忠实执行合约，所以合约有了约束力。同样，如果一个智能合约虽然没有在链上执行，但如果有分歧时，任何一方都可以让它在链上执行，则也同样产生了约束力。&lt;/p&gt;

&lt;p&gt;理论上，通过这样的方式可以支持无限的 TPS。&lt;/p&gt;

&lt;h3 id=&quot;智能合约的另外一种形态&quot;&gt;智能合约的另外一种形态&lt;/h3&gt;

&lt;p&gt;前面说的智能合约都是通过编程语言表达出来，在链上执行的程序，即便是放到链下，也需要保证可以在链上执行，否则就无法裁决。但既然我们关注的是约束力，重复验证只是实现约束力的一种方式，那有没有其他办法实现约束力？比如法院裁判合约的时候，并不是重复执行一遍然后验证，而是验证双方提交的执行结果证明，或者是对方认可结果的证明，比如签字。&lt;/p&gt;

&lt;p&gt;比特币上的”智能合约”就和这种机制类似。比特币的模型下，锁定脚本相当于一个锁，确定了交易输出的 BTC 的归属权，算不得前面定义的合约，但它可以通过密码学方式设置解锁条件，来达到合约的效果，比如实现两种数字资产的交换（相当于买卖合约）。具体的实现方式这里不详述，感兴趣的可以看看原子交换，闪电网络，以及基于 Schnorr 签名的 Discreet Log Contracts 。&lt;/p&gt;

&lt;p&gt;这种机制的思路是合约具体怎么执行不重要，只要保证合约最后争议的标的的归属权即可达到约束效果。当然，这种机制下，合约能表达的合约类型受限。&lt;/p&gt;

&lt;p&gt;前一段时间我们也做了一个小实验项目，试图在闪电网络上实现智能合约。参与方互相验证合约，有争议时通过仲裁服务节点仲裁，资产通过闪电网络的 hash time lock 机制互相抵押，仲裁方可以决定押金的归属，但无法直接取走押金。虽然也有联合作弊的可能，但联合作弊也有信任成本，风险要小于押金托管。&lt;/p&gt;

&lt;p&gt;至此，可以看出来。如果我们焦距于智能合约约束力的构建，合约的验证，裁决，执行，实际上是可以拆解开的，不一定要在同一层实现。&lt;/p&gt;

&lt;h3 id=&quot;智能合约未来的两种路线&quot;&gt;智能合约未来的两种路线&lt;/h3&gt;

&lt;p&gt;如果只追求约束力，对智能合约的发展并没太大分歧，但智能合约同时也是一种程序，它具有程序的所有特征，所以产生了分歧。&lt;/p&gt;

&lt;p&gt;为了能校验合约，链上会保留智能合约的状态以及输入参数，也就是说提供了存储能力，同时也提供了合约运行环境，提供了计算能力。有了这两种能力后，理论上任何互联网应用都可以搬到链上了，同时还具有了约束力。所以以太坊将自己定义为世界计算机，EOS 将自己定义为一种 OS，都是用来运行去中心化应用 DApp 的平台。&lt;/p&gt;

&lt;p&gt;然而 DApp 试验几年，还是没有大的起色。开始大家认为是 TPS 的限制，于是 EOS 通过 DPoS 的机制减少参与共识的节点，以达到更高的 TPS，理论上也可以运行一个小规模的互联网应用了，但依然没有太大起色。那问题到底出在哪里了？&lt;/p&gt;

&lt;p&gt;关键在于我们一直按照互联网应用的模式在思考 DApp，&lt;strong&gt;互联网应用的模式是提供一个系统给所有人用，应用本身所需要的状态存储和计算能力，和因为需要实现约束而产生的状态存储以及计算能力混合在了一起，所以几乎没有一个互联网应用的价值能撑得起区块链这样规模的副本和重复计算。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以现在智能合约和 DApp 的发展大体上可以分为两个方向：&lt;/p&gt;

&lt;p&gt;一. &lt;strong&gt;关注合约的约束力，必要的计算和存储只是实现约束力的基础&lt;/strong&gt;。这种思路下，开发者应该分析应用本身，拆解出需要约束的计算以及状态，也就是代表应用方与用户之间的合约的部分，然后构建证明和验证机制，只把必要的数据提交到链上裁决，链并不需要重复执行应用，与合约无关的计算和存储依然在链下。大多数二层网络，以及多链，跨链系统的约束和仲裁机制，走的是这个方向。&lt;/p&gt;

&lt;p&gt;这种路线下，最容易实现的是 DeFi 类的应用。因为这类应用需要约束的状态很明确，就是资产，通过智能合约的约束力解决资金托管难题。并且现实中的法律合约也大多实际和资产相关，如果能把现实中的法律合约迁移到链上执行或者仲裁，想象力空间是非常大的。这个路线面临的最大的难题不在于技术，而在于和现实法律的冲突以及社会认知的变更。&lt;/p&gt;

&lt;p&gt;二. &lt;strong&gt;关注计算或者存储能力，约束力只是用户信任硬件资源提供方的一种手段&lt;/strong&gt;。有了这种约束力，可以构建开放式的系统，吸纳更多更廉价的硬件资源。如果只以保证必要的安全性为目标，就可以减少重复验证以及存储副本，以期望给 DApp 提供比云平台更廉价的计算和存储能力，至少成本上不要高太多，价格差可以通过开放性来弥补。比如 Filecoin，Truebit 等。这种路线下，短期看来，成本以及可靠性要超越云平台还是比较难的，技术难度要超过第一种路线，但好处是现实阻力没那么大。&lt;/p&gt;

&lt;p&gt;当然，两个方向各有各的难度，也不冲突，最好是两个方向都成功了，就可以互相结合起来了。但如果试图同时在同一层实现两个方向，就会有冲突了，我个人认为是不可能的。&lt;/p&gt;

&lt;h3 id=&quot;对司法体系的启示&quot;&gt;对司法体系的启示&lt;/h3&gt;

&lt;p&gt;既然智能合约可以通过区块链进行裁决执行，那现实中的法律合约，是否也可以模拟出这样的体系，来降低司法成本？那我们假设下，如果现实中的法律合约要通过计算机仲裁，需要哪些条件。比如一个借款合同，一方声称还钱了，有转账记录为证，另外一方认为没还，说这次转账不是还款，是另外一个原因。如何实现软件程序裁决？&lt;/p&gt;

&lt;p&gt;首先，有一种编程语言来表达这个合约。&lt;/p&gt;

&lt;p&gt;其次，双方必须有一套数字证书身份，都对这个智能合约进行签名。&lt;/p&gt;

&lt;p&gt;再次，银行需要提供机制，转账时将转账记录和合约关联起来。同时提供给双方一个数字凭证，和凭证的验证接口。&lt;/p&gt;

&lt;p&gt;最后，法院的裁决程序通过数字证书验证双方身份，通过银行的数字凭证验证还款交易，运行合约进行校验，基本就可以进行裁决了，银行收到裁决的结果后执行即可。&lt;/p&gt;

&lt;p&gt;虽然这个过程有点简化，但理论上是可行的，并且基本的技术也都具备了，只是当前不同的系统之间还是割裂的，无法提供数字证明机制，数字证书身份体系也还缺失。&lt;/p&gt;

&lt;p&gt;所以，我一直建议法律人也可以关注下智能合约技术，虽然这个技术现在还没到成熟阶段，但它比法律合约的优势非常明显：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;表达无歧义，执行结果明确。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跨自然语言，世界通用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可计算机裁决，可预执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然还不敢说未来它的普及度有多大，但至少理论上，随着未来资产的数字化，大多数和资产相关的合约都可以通过智能合约表达执行。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;区块链领域有个说法叫 Code is law，代码既法律，实际上我觉得应该反过来，说 Law is Code。区块链以及智能合约就是想通过代码构建出一套约束力体系，用代码来描述这种规则（法律），将规则（法律）通过代码表达并执行。&lt;/p&gt;

&lt;p&gt;这套机制，如果从法律体系来看，是千年未有之大变革。它的意义堪比几千年前人类把文本作为法律刻在石头上。如果试验成功，就可能构建出独立于国家主权的法律体系来。前两天美国的开源基金会关于软件出口的限制引起很大争议，为什么开源基金会要注册到某一个国家呢？因为开源基金会也需要资金运作，需要银行账户，万一出现经济纠纷，还需要依赖现有的司法体系来裁决。但区块链已经造出了数字资产，有了组织定义能力，有了裁决体系，就有可能出现独立于国家之外的开源组织。&lt;/p&gt;

&lt;p&gt;当然有没有可能完全替代现实中的法律体系呢？这也是不可能的。毕竟终极制裁是对人的肉体进行制裁，除非有一天，人类真把自己的大脑上传到网上，现实中的肉体和资产对人来说完全失去了意义。不过也说不定呢？关于费米悖论的一个解释就是，外星人觉得现实的宇宙太大太无聊，于是把自己上传到了数字世界。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关链接&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;本文原始链接 &lt;a href=&quot;http://jolestar.com/what-is-the-smart-contract/&quot;&gt;http://jolestar.com/what-is-the-smart-contract/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Vitalik 谈论 smart contract 的推&lt;a href=&quot;https://twitter.com/VitalikButerin/status/1051160932699770882&quot;&gt;https://twitter.com/VitalikButerin/status/1051160932699770882&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Discreet Log Contracts &lt;a href=&quot;https://adiabat.github.io/dlc.pdf&quot;&gt;https://adiabat.github.io/dlc.pdf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A smart contract and arbitrate oracle service on LightningNetwork&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/starcoinorg/thor/&quot;&gt;https://github.com/starcoinorg/thor/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 27 May 2019 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/what-is-the-smart-contract/</link>
        <guid isPermaLink="true">http://jolestar.com/what-is-the-smart-contract/</guid>
        
        <category>smartcontract</category>
        
        <category>blockchain</category>
        
        
      </item>
    
      <item>
        <title>我看知识付费</title>
        <description>&lt;p&gt;最近朋友圈因为罗振宇的跨年演讲两级分化严重，引发了朋友圈转发斗文章大战。&lt;/p&gt;

&lt;p&gt;一派从罗振宇的演讲中感受到了知识，力量以及趋势，另外一派则认为是忽悠，鸡汤和骗局，还有一部分吃瓜群众不知道支持哪边好，好像都有点道理，或者两边都有熟人，抹不开脸，于是作壁上观。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;批评者们认为罗振宇们在贩卖焦虑，满足了一部分人试图轻松获取知识的『妄念』，和权健之流通过满足一部分人轻松获取『健康』的妄念，贩卖保健品的路数一样，差不多把『知识付费』连盆带水一起倒掉了。罗振宇们则认为批评家喷子居多，做事的人和搞评论的人，完全在两个世界，就如罗在演讲中举的那个例子，『我·妈·水测试』，真掉水里要决策的时候和假设讨论的结果完全没多大关系。&lt;/p&gt;

&lt;p&gt;先用小刚编个故事场景来说明两者的差异：&lt;/p&gt;

&lt;p&gt;小刚：老师，老师，我想通过网上知识付费内容学知识，靠谱吗？
老师：不靠谱，知识付费内容太碎片化，不系统，只是传播一些观点和结论。&lt;/p&gt;

&lt;p&gt;小刚：老师，老师，我拉屎的时候，刷完了朋友圈微博，看腻了小姐姐跳舞，听点知识付费节目学点知识可以吗？老师：很好啊，学一点是一点。&lt;/p&gt;

&lt;p&gt;批评者们多从前者的角度来说，而罗振宇们则看到的是后面的机会。现在的知识内容抢占的实际上并不是传统的教育市场，而是整个互联网内容升级的延续。这点上罗振宇非常清楚，他从来不把自己定义成教育者，而是降低姿态，以知识服务者自居。用户是老板，他好比是老板雇佣的秘书，每天整理一些资料呈现给老板。如果老板觉得太难，他就通俗点，如果老板觉得无趣，他就多讲故事，如果老板觉得有意思，想进一步深入了解，就去了解下，如果没意思也不用太有压力。&lt;/p&gt;

&lt;p&gt;你说他们这是知识服务也好，是精神按摩也好，创业者总是从用户的需求出发。如果你说精神按摩只是造成幻觉，解决不了问题，但只要用户需求进一步成熟，市场中也肯定能出现提供精神大保健服务的给你解决问题。&lt;/p&gt;

&lt;p&gt;而批评者们说的问题虽然都有，但却往往以一副居高临下的姿态开启鄙视链，鄙视用户，对提出解决方案一点益处没有。这里面有一部分是知识分子的自命清高，有一部分则是变相标题党而已，语不惊人死不休。&lt;/p&gt;

&lt;p&gt;如果觉得现在的知识付费内容都是辣鸡，那说明竞争不充分，更应该鼓励供给者啊。辣鸡都能赚到钱，那市场就是发出『千金买马骨』的信号，自己如果是千里马还不赶紧上？&lt;/p&gt;

&lt;p&gt;如果觉得当前这种付费模式就是健身房忽悠人的会员卡模式，那能不能搞一种新的付费模式？比如按使用时间付费？&lt;/p&gt;

&lt;p&gt;良性的批评应该是帮助市场进行优劣淘汰，帮助用户解决问题，而不是一巴掌把市场全拍死。&lt;/p&gt;

&lt;p&gt;有人要问，如果我认为这个市场领域本身就是一个虚妄的存在呢？比如保健品之类的。这个问题如果有说服过家人或者朋友放弃保健品的经历的人就会明白，如果你以布道者或者批评者的姿态去说服，就直接站到了对立面上，是肯定说不服的。你得理解他们的需求，并且能提供替代品，如果确实没有替代品，那就权当安慰剂吧。并且你还得指望市场中的竞争再激烈一些，有没有用另说，至少别有害。鸿毛权健之流，最恶劣的地方是他们操纵公权力，虚假宣传医疗效果害人，这方面实际上是市场竞争不充分，监管机构失职导致的。&lt;/p&gt;

&lt;p&gt;叔本华说：莫让自己的头脑成为别人思想的跑马场。鲁迅说，如果你相信这句话，头脑就被叔本华跑了一遍了。如果你看了罗振宇的演讲，又看了罗振宇的骗局，再看了我这篇短文，头脑就被三个人跑过了。实际上要培养自己对忽悠免疫力的唯一方式就是多让一些人的思想进来跑马。一个人成熟的标志就是脑袋里能容纳多种冲突的价值观，没事的时候在自己脑子里斗争一下。&lt;/p&gt;

</description>
        <pubDate>Fri, 04 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/talk-about-knowledge-as-valuable/</link>
        <guid isPermaLink="true">http://jolestar.com/talk-about-knowledge-as-valuable/</guid>
        
        <category>knowledge-as-valuable</category>
        
        
      </item>
    
      <item>
        <title>通过 ofo 退押金事件看区块链二层解决方案</title>
        <description>&lt;p&gt;最近几天 ofo 退押金一直是个热门话题，据说排队退押金的人已经超过 1000 万了。&lt;/p&gt;

&lt;p&gt;像 ofo 这种退押金机制的关键问题是退押金必须和商家协作完成，如果商家不协作，或者故意制造门槛，用户就很难退押金。当然更恶劣的情况就是直接跑路了，比如各种美容店，健身房卷了会员充值的钱跑路的例子。&lt;/p&gt;

&lt;p&gt;从法律角度说，用户给服务方的押金以及充值，都是服务方代管的资金，当用户没发生实际消费之前，服务方无权动这些资金。但钱都转到人家帐上了，如何防止被挪用？&lt;/p&gt;

&lt;p&gt;那能不能设计一种非协作式退款提现机制，把充值资金托管给有公信力的第三方，比如银行，然后用户退款的时候直接和银行交互，无需商家协作？比如直接拿从银行给商家充值的订单退款？
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;但实际上没这么简单，银行如何相信你没在商家的应用中花费掉了这笔钱？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/ofo-layer2/app-and-bank.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示（画图水平有限，将就着看），应用服务器和客户端实际上是一个体系的，客户端依附于应用服务器，无法独立运行。应用系统和银行系统之间通过支付接口连接，应用自己的账本和银行的账本之间是没有关联的，一旦应用方中断和银行或者和客户端的连接，用户就无法提现，也无法向银行证明自己的在应用中的余额。&lt;/p&gt;

&lt;p&gt;要解决前面的问题，需要把关系调整为下面这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/ofo-layer2/app-and-bank2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用的账本和银行的账本之间需要建立一种映射关系，相互关联起来。客户端是独立的，它保存了带有数字签名的证据，同时和应用与银行连接，如果应用自己中断和银行的连接，用户可以通过客户端直接向银行提供数字证据来完成退款，而不需要应用的协作。&lt;/p&gt;

&lt;p&gt;详细的说，要设计这样一个方案需要有以下关键点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;要找到这样一个有公信力（商家，用户都信任）的机构，如果只是一国内应用，就比较容易，比如银行吧。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要有一个账号，这个账号不受商家控制，用户直接把钱充进这个账号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;由于用户充值退款都是直接和银行交互，所以银行需要有一种机制通知商家有用户充值或者退款了。&lt;/li&gt;
  &lt;li&gt;用户中会有恶意用户，可能把钱消费了后迅速向银行发起退款。所以银行对退款必须有一个锁定期，这个锁定期内，商家可以提交证据，证明用户已经消费或者造成损失了，然后撤销退款。&lt;/li&gt;
  &lt;li&gt;而用户可能也会发现商家的作弊行为，比如私扣余额等，可以给银行提供证据，由银行裁决对商家进行惩罚。所以用户的本地客户端需要有离线能力，不能完全依赖商家的服务器，每次交易后，需要从商家获取证据，保存到本地，为以后提交证明准备。&lt;/li&gt;
  &lt;li&gt;由于银行实际上不可能保存用户在应用中的所有交易记录，它无法直接进行裁决，所以商家需要定期将自己本地记录的数据哈希（数据指纹），提交给银行，产生争议的时候，用户和商家互相举证进行挑战，证据需要和历史上提交的哈希相关。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个方案看起来好像有点复杂，估计没有一个银行愿意干这个事情，因为成本有点高。但如果把上面的所有的举证以及裁决都数字化，由程序完成，相当于一个应用对用户的公开可执行合约，托管在银行，实际上成本就可以接受了。&lt;/p&gt;

&lt;p&gt;熟悉区块链的朋友，可以看出上面的方案其实就是区块链的二层(layer2)方案的关键点，那个合约就是区块链的智能合约，这里的银行就是代表了区块链。区块链技术发展到现在，大家都认识到公链这样的全球共识系统本身成本肯定很高，很慢，短时间很难有大的突破，所以可扩展问题需要通过链外方案解决，比如交易所以及中心化钱包。但这些方案都完全依赖用户对这些服务提供方的信任，用户充值退款都需要服务提供方协作，一旦发生黑天鹅事件，出现 ofo 这样的情况还算好的，更恶劣的情况恐怕就是跑路了，而作为一个全球化的系统，用户想起诉估计都不知道找哪里的法院。&lt;/p&gt;

&lt;p&gt;所以区块链二层的各种方案主要焦距点是如何设计一种机制，一方面让服务提供方可以自证清白，建立公信力，另外一方面给用户提供一种额外的制约机制，让用户来监督服务提供方，一旦有问题用户可以通过一层的链来进行裁决。这样链主要关注于安全，相当于扮演一种法院的角色，只需要处理有争议的交易，二层主要关注性能和扩展性，区块链就可以应用到更广阔的场景中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/ofo-layer2/ofo.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个行业中的企业如果不能自证清白，只能天下乌鸦一般黑，因为自我操守坚持不能形成竞争优势。比如有一个有良心的共享单车创业企业，承诺不挪用用户的资金，但它怎么证明自己呢？所有的企业在公开场景下都做这样的承诺，用户如何相信？如果你不挪用，别人挪用了，别人有了资金竞争优势，结果就是大家都挪用。而在前面的方案中，用户的资金是被锁在企业无法控制的账号中，并且用户可监督，就提供了这样一种证明机制。如果 ofo 现在有办法证明用户的押金都在，没有被挪用，未来也不可能挪用，用户可能就不着急退款了，越是不容易退，用户越要通过退款来验证，和银行挤兑一个道理。&lt;/p&gt;

&lt;p&gt;而从监督方面看，随着互联网的发展，支付交易凭据都电子化，用户对服务提供方的监督能力在降低。没互联网的时候，用户可以保留服务提供方的纸质凭证来作为证明。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/ofo-layer2/deposit-book.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​                  （图片来自新浪科技新闻 — 从现金到手机支付，你还记得记忆中的存折吗？）&lt;/p&gt;

&lt;p&gt;比如，现金时代，我们取钱存钱都通过存折，存折实际上提供了一种证据保存能力。用户取钱的时候可以校对余额，如果存折和银行数据不一致就很容易发现。但现在都用客户端 App，App 的数据都是直接从银行服务器上下载的，没有客户端校验机制。如果数据有误，但误差不大，有几个人可以发现？比如前一段时间的一个银行内部员工盗钱的新闻，最后还是银行内部对账发现。更严重的是，万一银行把用户的数据丢了，如果没有存折，用户如何证明自己有多少钱存款？登陆银行APP查看？数据都没了怎么登陆？&lt;/p&gt;

&lt;p&gt;当前，用户将一个封闭账本体系里的价值转移到外部系统，是制约服务提供方的终极方式。比如 ofo 退款，比如从交易所提出比特币，比如从银行把现金取出来。正是迫于用户提现的压力，服务提供方才会在意自己的信用。而区块链二层方案中，客户端的独立存证校验能力相当于重新实现了数字化的存折，并且把校验机制自动化。再配合数字化的举证和裁决，以及非协作式提现机制，就可以实现用户对服务提供方的监督和制约。&lt;/p&gt;

&lt;p&gt;写到这里，提一个值得思考的问题：充值到商家账本里的钱可以通过提到银行来进行制约，那如果未来货币完全数字化，没有了现金，用户把银行发行的数字货币提到哪儿去？这个问题会在后面一篇关于央行的数字货币的文章中分析。&lt;/p&gt;

&lt;p&gt;区块链的二层（layer2) 方案并不只是解决区块链自己造出来的问题，它具有普适性。虽然相关技术尚未成熟，但至少提供了一种解决思路。关于区块链二层的各种技术方案的详细对比，后面会写专门的文章进行分析。&lt;/p&gt;

&lt;p&gt;最后再谈下对 ofo 的看法。ofo 的这个例子非常典型，无论结局最后如何，对未来的创业者以及用户都有警示作用。 有人觉得创业不易，这时候呼吁退押金好像有点落井下石。实际上我个人也挺愿意用这点押金去支持创业者，但关键问题是企业拿了用户的押金去创业，而用户有什么收益呢？成功了收益是创业者的，失败了用户的押金都没了。至少要明确告知用户这算作投资，做到风险收益对等才行。比如一个早期用户在 ofo A轮的时候加入，算 200 块入股，当时 ofo 融资 2500万人民币，估值大约 1 亿人民币左右吧。到 17 年 ofo E 轮融资估值到了 30 亿美元，市值涨了有 200 倍，用户的 200 块押金估值相当于 40000 元，如果 ofo 不倒闭，估计骑一辈子单车的钱也够了吧。用户愿不愿意拿 200 块堵一个一辈子免费骑单车的机会？当然，这样规模的股东是当前公司注册机制无法承载的，肯定需要组织以及金融模式上的革新，当然这就属于另外一个话题了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关链接&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;本文原始链接 &lt;a href=&quot;http://jolestar.com/ofo-and-blockchain-layer2/&quot;&gt;http://jolestar.com/ofo-and-blockchain-layer2/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;区块链的技术世界观 &lt;a href=&quot;http://jolestar.com/blockchain-technology-overview/&quot;&gt;http://jolestar.com/blockchain-technology-overview/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;无币区块链代表未来？浅谈联盟链以及对 Hyperledger、 Corda、FISCO BCOS 的比较 &lt;a href=&quot;http://jolestar.com/consortium-blockchain-hyperledger-corda-fisco/&quot;&gt;http://jolestar.com/consortium-blockchain-hyperledger-corda-fisco/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 20 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/ofo-and-blockchain-layer2/</link>
        <guid isPermaLink="true">http://jolestar.com/ofo-and-blockchain-layer2/</guid>
        
        <category>blockchain</category>
        
        <category>layer2</category>
        
        <category>ofo</category>
        
        
      </item>
    
      <item>
        <title>无币区块链代表未来？浅谈联盟链以及对 Hyperledger、 Corda、FISCO BCOS 的比较</title>
        <description>&lt;p&gt;最近流行一个说法是币圈凉了，无币区块链代表未来。一直以来对区块链技术有几种看法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只有比特币，没有区块链。区块链只是为了实现比特币而采用的一种不得已而为之的技术，没有什么先进性，也没有通用性。除了比特币，全是山寨币，全是骗子，更遑论无币区块链。&lt;/li&gt;
  &lt;li&gt;比特币是区块链技术的一个特殊案例，区块链技术可以用到更广阔的场景，骗人的都是发币的，搞无币区块链的不是骗子。&lt;/li&gt;
  &lt;li&gt;上面两种人都是骗子，区块链都是骗子。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;鉴于第三种看法前一段时间因为一篇文章广泛流传，个人作为一个区块链技术人员，觉得应该写点什么。一直想写一个系列，但年初的时候区块链鼓吹者甚多，作为一个技术人，完全插不上嘴。最近熊市，冷清了许多，决定写一写。前一次从账本技术演进的角度写了区块链技术的演进《&lt;a href=&quot;http://jolestar.com/blockchain-technology-overview/&quot;&gt;区块链的技术世界观&lt;/a&gt;》，这次说说无币区块链 — 联盟链。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;公链联盟链私链的划分&quot;&gt;公链，联盟链，私链的划分&lt;/h2&gt;

&lt;p&gt;业界对区块链的划分一般从两个角度，一个角度按需要达成的共识范围，分为公链（public），联盟链（consortium），私链（private），另外一个角度是从账本生产者加入的方式，分为无许可链（permissionless），许可链（permissioned），私链（private）。&lt;/p&gt;

&lt;p&gt;这里要谈的联盟链对应的就是 consortium 和 permissioned。&lt;/p&gt;

&lt;p&gt;但 permissionless 和 permissioned 之间的界线实际上并没有那样清晰。比如关于 EOS 的争论。有人认为这样的超级节点数有限的链，就是一种超级节点之间的联盟链。permissionless 就必须是出块节点无限，纯粹的 Peer to Peer 网络，理论上任何一个节点加入后可单凭自己的意愿和力量就可成为出块节点。反对者则认为，EOS 没有准入限制，任何人都可以竞选超级节点，是否能竞选上就取决于用户投票，permissionless 关注的是可能性，调动物力资源（算力）和调动社区力量，都是需要成本的，本质上一样。这就引出了一个关键问题，如何理解 permissionless 和 permissioned ？谁来许可？&lt;/p&gt;

&lt;p&gt;所以为了避免争议，我自己提出一种划分方式，可通过链是否可以『自举』，来进行划分。自举包括经济和治理两个方面。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;经济&lt;/strong&gt; 链本身的运行成本分摊以及激励分配是如何进行的？是否在链上进行？&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;治理&lt;/strong&gt; 如果准入机制或者分配机制上需要协商，协商结果是否在链上可执行？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果上面两个问题回答为是，则可认为这个链是一个自举的链。然后我们从这个角度来看看现在的联盟链。&lt;/p&gt;

&lt;h2 id=&quot;先有联盟还是先有链&quot;&gt;先有联盟还是先有链？&lt;/h2&gt;

&lt;p&gt;我们假设一个联盟链的启动场景，有几个市场主体，决定要成立个联盟，启动一个链来共享数据。于是协商好各联盟成员在联盟中角色，投票权重，准入机制，承担的责任，利益分配等等，这些机制，要么落实为合同，要么再成立个合资公司，落实为公司股权以及章程。然后找一个联盟链的技术供应商，购买联盟链系统，启动联盟链。&lt;/p&gt;

&lt;p&gt;而另外一种启动方式是，把联盟本身的成立，组织，准入，责任利益分配等治理机制都通过链来进行，将线下的合同，转换为链上的共识代码逻辑，它本身就变成了一种可『自举』的链，联盟本身是由链组织起来的，这和前面说的公链实际上没有了本质的区别了。&lt;/p&gt;

&lt;p&gt;这也是当前联盟链当前两条路径的主要差异，一派认为应该先有联盟，链只是一个工具，提供方把自己定义成一种区块链软件系统提供方，关注当前现实的可行性以及合规性。另一派认为先有链，联盟是链上的产物，更像是链服务提供方，更关注未来的可能性。&lt;/p&gt;

&lt;p&gt;当然，后面这套机制如果试图通过程序表达出来，并且达到最后的可执行效果，复杂度超过可能当前所有公链的治理机制，并且也一定程度依赖法律的变革，所以当前的联盟链服务商都采取了一种简化策略。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;去除掉公链内部的经济系统。公链的经济系统本身是为了激励和惩罚参与者而设计的，没有了经济系统，本质上是把利益分配机制转移到链下的传统方式。&lt;/li&gt;
  &lt;li&gt;暂不引入链上的治理机制，通过提供配置参数以及可拔插的组装能力，以适应不同联盟的需求，简化复杂度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;去除了上面两个难点，很大程度上降低了链的实现复杂度，联盟链现在焦距的方向主要是链的吞吐，开发者的支持，业务场景的适配。&lt;/p&gt;

&lt;h2 id=&quot;联盟链的应用场景在哪里&quot;&gt;联盟链的应用场景在哪里？&lt;/h2&gt;

&lt;p&gt;区块链造出了币，造出了融资平台，造出了交易所，也该到造应用，将区块链应用到更多行业和场景里去的时候了。当前新的公链和联盟链其实都是这个趋势下的产物，主要都在探索应用场景。&lt;/p&gt;

&lt;p&gt;谈论区块链的时候，很多人的第一个问题就是它到底能用在哪呢。这个问题其实可以拆解成两个问题，它未来有什么用，和它当前有什么用。很多质疑区块链的人混淆了这两个问题，你谈论未来的时候，他拿现状质疑，你谈论现状的时候，他拿未来嘲讽。&lt;/p&gt;

&lt;p&gt;第一个问题其实就是，假设区块链的网络已经建立起来，网络效应发挥出来之后的可能性。谈论可能性的时候，容易放飞自己，听着就像忽悠，所以这里先从背景和趋势进行演绎。&lt;/p&gt;

&lt;p&gt;区块链要解决问题的大背景是信息互联网在各行各业的进一步深化，也就是常说的互联网+，或者互联网进入 B 端，从以前连接消费者（C 端）转变到连接企业（B 端）或者连接组织（包括 G 端，政府）。&lt;/p&gt;

&lt;p&gt;但C 端直接面向的是人，以信息展示为主，商业模式主要依赖吸引终端用户的注意力。而要连接 B 端，依赖的是企业间系统互通，以信息和价值互换为主。给人的信息展示对数据格式化以及标准化要求并不高，但如果是系统间的交互，则对数据格式，流程，协议有严格要求，如何让不同企业的内部系统遵循同样的数据，流程，协议，然后连接成一个网络，形成网络效应？&lt;/p&gt;

&lt;p&gt;一个方向是沿用互联网模式，让 B 端都接入到一个互联网平台上，然后再通过平台内部连接。但如何吸引 B 端呢？一种尝试是通过 C 端的流量来吸引 B 端，比如电商以及外卖平台等都是这个思路。但这种连接比较浅，依然沿用的是互联网流量入口的模式，并没有实现 B to B 的连接。另外一种尝试是 SaaS 服务，将企业内部应用互联网化，如果服务普及到一定程度，就可能实现企业与企业之间的连接。但你可以设想全中国的人都用微信来聊天，但能构想一个在线企业服务，比如财务系统，全中国的企业都用吗？&lt;/p&gt;

&lt;p&gt;还有一种方向是行业标准或者行业联盟提供的平台。比如金融领域的 FIX(Financial Information eXchange，金融信息交换协议) ，或者银联这样的组织提供的结算平台。但标准以及协议只能定义通信格式，很难定义业务逻辑，更难实现统一的数据处理逻辑，而银联这种行业联盟平台构建的成本太高，不可能适用到所有行业。&lt;/p&gt;

&lt;p&gt;而区块链展示出的一个蓝图是，数据的校验，处理流程，乃至组织的治理都可以通过代码定义，各参与方遵循同一套规则，这套规则是活的运行中的代码，而不是死的文档中的规范，是一种更高级的行业协议联盟，是 Software Defined X 趋势在行业内的延续，比如 SDF(软件定义金融，Software Defined Finance)。&lt;/p&gt;

&lt;p&gt;比如拿比特币来举例，把比特币网络理解成一个清算网络，各交易所是接入这个清算网络的企业。以前企业间需要数据互通，只能互相谈判对接接口，系统接口还必须保持兼容。而有了比特币这套网络后，只要遵循比特币规则接入到网络中，即可和全球其他任意企业进行价值互通，用户的比特币即可在不同交易所之间流动。&lt;/p&gt;

&lt;p&gt;把上面的交易所，替换成任何一个 B 端系统。比如企业财务系统，企业间的对账直接通过网络进行，内部账单保存在本地，再配合政府的电子发票，基本就实现了记账对账审计一整套体系，政府审计查账那就太容易了，跑一个程序就搞定。这也是为什么政府支持区块链的原因。&lt;/p&gt;

&lt;p&gt;单从行业来说，金融领域是最关注区块链的。如果说互联网给金融带来的压力只是入口之争，而区块链带来的压力则是根本性的。所以金融机构对区块链有一种矛盾的心态，一方面想积极拥抱，联盟链基本上都有金融背景，另外一方面又有排斥，毕竟定义货币，债券，股票以及数字资产是金融机构的生存之本。但区块链带给金融的不仅是挑战，更多的是契机，比如全球化。&lt;/p&gt;

&lt;p&gt;再比如溯源防伪，供应链方面的场景。看到过很多批评溯源的文章，核心在纠结一点：真实世界到信息世界的映射的过程如何防作弊。如果纠结这点，基本上区块链就只能用于像比特币这样纯信息世界的场景，数字资产从诞生到流通，一直在数字世界。但实际上，人类的大多数资产以及信息，都不是直接在信息世界产生的，也无法直接在信息世界验证。正如我在一篇《公链的关键竞争点在哪里？》的文章中所述，溯源最后正真的价值并不只是用来防伪，只是当前这个阶段防伪只是一个容易体现价值的点。溯源最后实际上是在定义数字资产。每个商品，如果把它从生产运输销售中的所有环节的追踪到了，实际上就是定义了这个商品的数字标志，把它 Token 化了。这个过程会涉及整个产业链的每个环节，以及其中的金融机制，重构商业体系，肯定不仅仅是一个信息采集和共享的事情。&lt;/p&gt;

&lt;p&gt;关于未来这里不进一步畅想，这方面有很多书籍文章，我们再谈谈下一个问题，现状。&lt;/p&gt;

&lt;h2 id=&quot;联盟链的困境&quot;&gt;联盟链的困境&lt;/h2&gt;

&lt;p&gt;区块链当前遇到的困境其实和互联网应用初期遇到的困难类似。区块链和互联网应用都有网络效应，它所绘制的蓝图需要在网络构建完成后才能体现出来，初期个体的采用并不能享受到网络带来的好处，那初期用户有什么动力来采用区块链呢？如果说公链还可以依赖自己的经济体系做早期激励，互联网应用可以利用各种营销手段，对 to B 的无币联盟链来说，这个问题尤其困难。B 端用户的决策周期长，采用成本高，尤其区块链的应用架构和传统应用差异巨大。&lt;/p&gt;

&lt;p&gt;所以当前的联盟链创业者初期肯定是需要在路径上摸索和寻求突破，比如我这里可以列举几个可能的途径：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;以开发的便利性作为突破。区块链的智能合约模型，提供了一种更优雅的应用开发模式，平台完全接管应用的输入输出以及运行环境，开发者可以更专心于业务逻辑。这个和 Docker，Kubernetes，ServiceMesh，Serverless 的演进是一个体系的。也和朋友聊过通过更轻量的沙箱 VM 替代 Docker 的想法，有空再仔细写一下这方面的思路。&lt;/li&gt;
  &lt;li&gt;以安全和容灾作为突破。区块链的架构完全符合异地多活的架构要求，并且可以做的更可靠优雅（可参看我的 《&lt;a href=&quot;http://jolestar.com/blockchain-technology-overview/&quot;&gt;区块链的技术世界观&lt;/a&gt;》中的相关段落分析）。&lt;/li&gt;
  &lt;li&gt;以内部监管作为突破。可适用于很多复杂体系的企业，比如总公司和分公司使用不同的系统。&lt;/li&gt;
  &lt;li&gt;以构建公信力作为突破。利用区块链的几个特性：1. 用户对自己数据的控制能力。2. 联盟成员互相制约。3. 数据的公示与监督。可以帮助创业者以更快的速度构建公信力，而在之前，基本上公信力只能靠时间来构建（比如保险行业，用户选择保险的时候很关注的一点就是保险公司持续的时间）。&lt;/li&gt;
  &lt;li&gt;以跨系统的信息互通和结算作为突破。在区块链之前，跨系统的信息互通和结算基本靠远程调用，很难保证一致性，所以必须有独立的对账清算机制，而通过区块链的共识算法，可实现交易即清算，提高效率。这种方式相当于实现一种基于区块链的异步消息机制的远程方法调用，而不用侵入已有业务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前三种，偏向于前面说的第一派联盟链的思路，企业先内部独立用起来，突然有一天发现可以用同一套系统和外部对接。后两种偏向于第二派思路，先构建出网络优势，再说服企业加入。如果你有其他的想法，也可以留言探讨。&lt;/p&gt;

&lt;h2 id=&quot;看看现在的联盟链&quot;&gt;看看现在的联盟链&lt;/h2&gt;

&lt;p&gt;这里为了照顾到非技术读者，所以本文不详述这几种联盟链的技术细节区别。只是从它们解决问题的思路方面进行分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hyperledger Fabric&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hyperledger 实际上把自己定位成模块化区块链平台，包括共识机制等都是可替换的。&lt;/p&gt;

&lt;p&gt;在联盟链场景下，它简化了计算证明的要求，允许用户以任意语言开发应用，并部署到 Docker 中运行，被称为 chaincode，相当于托管到链上的应用。开发者不需要懂太多区块链知识，只需要知道它接管了应用的输入，并通过提供 SDK 的方式，接管了应用输出即可。甚至可以理解成一个微服务框架，不过拥有区块链的共识能力，很容易实现多节点数据同步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R3 Corda&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Corda 的思路比较特别，它内部甚至不是一个区块的链式结构，只维护了交易的链式结构。它认为只需要交易双方达成共识即可，不需要维护全局账本，所以设计了一种公证人（notary）的机制，由公证人见证交易，只有必要的时候才启动共识协议。&lt;/p&gt;

&lt;p&gt;它提供了一套 Flow 机制，方便定义需要多方参与的流转式交易。它的合约就是 Java 或者 Kotlin 代码，不过都是无状态的，只负责校验，不保存状态，同时还内置了许多金融合约的实现，应用打包后就是一个 farJar 包，叫做 CorDapp，可直接托管给平台，相当于一种平台插件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;金链盟 FISCO BCOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FISCO BCOS（以下简称“BCOS”）是基于以太坊改造的联盟链。将以太坊的共识机制改造为 PBFT 或者 RAFT，并提供系统合约来实现节点管理，系统配置等能力。它的合约以及交易，主要继承自以太坊，不过废弃了以太坊的 Ether，所有资产都通过合约实现。&lt;/p&gt;

&lt;p&gt;BCOS 提供了一种链下网络上互通消息的能力，节点之间可以先通过消息来通信，实现一些协议，只有必要时再上链。它对以太坊的改进点主要关注在性能和安全层面。性能层面比如对 Global Trie 的改造，通过多链并行解决热点账号问题等。安全层面的改进主要是增强密码方面的支持以及脱敏隔离，因为以太坊是一个全局账本，不支持局部共识机制，必须通过其他手段来保护数据。&lt;/p&gt;

&lt;p&gt;可以看出，当前的联盟链的关注点还主要在性能，开发支持，应用场景。业界也对联盟链如何和公链的融合以及实现『自举』有探讨，比如前一段时间讨论的公众联盟链（参看文末链接），不过技术层面的融合机制还在探索阶段。联盟链可以利用公链的安全来进行数据公正以及裁决，实现联盟链本身的自证清白，以达到更高的公信力，最终实现更好的融合，这个其实就是区块链 layer2 的方案了。我们留到下一篇文章中分析。&lt;/p&gt;

&lt;h2 id=&quot;一些应用案例&quot;&gt;一些应用案例&lt;/h2&gt;

&lt;p&gt;一直也在琢磨区块链的案例。正好前一段时间金链盟举行了一个大赛，看到一些参赛案例。具体的代码和实现没看到，所以只是从脑洞和当前落地的可行性方向分析下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;政务类&lt;/strong&gt; 相当于 to G 的场景。这个领域实际上可做的事情非常多，比如最简单的信息公开。当前大多数政府信息公开还是原始的网页或者办公文档，并没有格式化的信息，第三方很难再次加工利用。如果通过区块链方式开放格式化的标准信息，则更有价值。比如大赛中出现的不动产登记、智慧城市服务、信用共享等应用场景的案例。这个领域的实施难度不在技术，关键在如何驱动。就比如，最简单的，工商登记部门提供一套证书机制，企业注册时生成数字证书，证书效力和公章一样，这样所有的数字合同场景都可以用得上，这个甚至都不需要用区块链就能实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;司法类&lt;/strong&gt; 比如做存证固证平台的，如果做好了，完全可以简化从公安，到检察院，再到法院的整个办案的证据提交和转移流程。实际上是政府部门间协作的流程的标准化以及软件化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;教育类&lt;/strong&gt; 比如学历链上登记等。本质上其实就是把学历证明数字化。当然这个没区块链也能实现，但如何让所有的学校都加入到这个系统形成网络呢？还是回归到了前面的问题。另外有一个项目挺有意思，图书漂流系统。相当于把图书 Token 化，把图书馆变成了流动的。以前是图书必须先还给图书馆，别人才能借，而现在读者间即可互相转借，Token 的转移代表图书的转移。如果配合押金以及惩罚机制，这个可以完全做成一种开放式的公益图书平台。&lt;/p&gt;

&lt;p&gt;其他的金融以及供应链类的案例，就更多了。这方面社区里也谈论的比较多，这里就不细说了。&lt;/p&gt;

&lt;h2 id=&quot;开放式问题&quot;&gt;开放式问题&lt;/h2&gt;

&lt;p&gt;联盟链当前还有一些开放式问题，暂时没有答案，等待探索。&lt;/p&gt;

&lt;p&gt;联盟链上应用和链的关系应该如何划分？是链直接托管应用，还是应用在链外？那具体哪一部分应该在链外呢？是否可提供整体方案？&lt;/p&gt;

&lt;p&gt;联盟应该横向连接还是纵向连接？横向是行业内联盟，纵向是产业链联盟，关注点不一样，解决方案也不一样。异或有统一的方案？&lt;/p&gt;

&lt;p&gt;联盟链如何连接最终用户？最终用户在联盟链处于什么角色？对自己的数据有控制权吗？当前的联盟链方案多关注联盟成员之间的数据互通，实际上只有将最终用户也纳入进来，才能形成完整的生态。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;本文试图通过联盟链来分析区块链的应用场景。我个人支持任何类型的区块链落地探索，无论是私链，联盟链还是公链。无币联盟链相当于改革派，期望在当前的金融框架内进行技术改革。而有币公链相当于革命派，试图重造一套金融体系。但实际上二者是互相依存的，如果没有公链的压力，改革也很难推动，而如果没有联盟链的改革，未来也很难实现区块链网络的融合以及价值的互通。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关链接&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;区块链的技术世界观 &lt;a href=&quot;http://jolestar.com/blockchain-technology-overview/&quot;&gt;http://jolestar.com/blockchain-technology-overview/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;马智涛：公众联盟链很可能是打开分布式商业模式大门的钥匙 &lt;a href=&quot;https://baijiahao.baidu.com/s?id=1611323109728919834&quot;&gt;https://baijiahao.baidu.com/s?id=1611323109728919834&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Hyperledger 核心开发者陈昌谈联盟链和公有链混合架构如何实现？ &lt;a href=&quot;https://mp.weixin.qq.com/s/ivawwP6pWYzTEXIDRgFQFg&quot;&gt;https://mp.weixin.qq.com/s/ivawwP6pWYzTEXIDRgFQFg&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 06 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/consortium-blockchain-hyperledger-corda-fisco/</link>
        <guid isPermaLink="true">http://jolestar.com/consortium-blockchain-hyperledger-corda-fisco/</guid>
        
        <category>blockchain</category>
        
        <category>consortium</category>
        
        <category>hyperledger</category>
        
        <category>corda</category>
        
        <category>fisco</category>
        
        
      </item>
    
      <item>
        <title>区块链的技术世界观</title>
        <description>&lt;p&gt;本文是基于我在 360 区块链开放日上的分享整理完善而成，演讲时有些逻辑没有讲明白，感觉用文字表述可能更好一些。作为自己区块链系列的开篇第一篇，谈谈怎么从技术的角度理解区块链。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/wordcloud.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说到区块链技术分享，区块链相关的各种技术词汇就纷至杳来。区块链领域是一个喜欢造新词的领域，这也给想了解这个领域技术的人造成了门槛。我一直想梳理下区块链的技术演进逻辑，试图从互联网技术的发展角度来解释区块链技术，这样可以让互联网领域的技术人更容易理解区块链。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;技术有没有世界观？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;技术本身的目标是对现实抽象和建模，所以技术实际上有自己对世界的理解和假设。比如编程范式里的面对对象和函数式编程，有完全不同的世界观理解。而区块链对世界是一种怎么样的抽象呢？&lt;/p&gt;

&lt;p&gt;我们还是从萧伯纳那句名言开始。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你和我各有一个苹果，如果我们交换苹果的话，我们还是只有一个苹果。但当你和我各有一个想法，我们交换想法的话，我们就都有两个想法了。&lt;/p&gt;

  &lt;p&gt;— 萧伯纳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这句话也被很多人用来解释区块链以及互联网的区别。交换苹果代表价值交换，交换想法代表信息交换。信息交换可以保留多个副本，但价值交换就不行。所以流行的一个说法是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;互联网-信息交换&lt;/p&gt;

  &lt;p&gt;区块链-价值交换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是交换信息就不需要考虑价值了么？其实也不是，毕竟贡献想法也是需要激励机制的。现在的互联网就没有价值交换了吗？区块链不也是在信息世界的吗？本质的问题实际是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如何在信息世界进行价值交换？或者说如何通过交换信息的方式进行价值交换？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个问题其实也不是一个新问题。在没有互联网的时代，人类就在尝试。比如各国都普遍实行的不动产登记制度。你买房买的是房子的控制权吗？或者说买房的时候你住进去就算买到了吗？实际上不是，要不动产登记账本变更后才算，这个登记变更实际上就是信息交换。无论这个账本是原来的纸质账本，还是变成计算机的数据库，甚至再到未来的区块链，载体变了本质上是没变的。再比如银行的财产登记，股票交易所的股票登记，都是一个道理，如果说货币还有纸币这种物理实体代表，股票则是纯信息化的，没人见过股票长什么样子吧。&lt;/p&gt;

&lt;p&gt;所以总结一下，&lt;strong&gt;信息世界进行价值交换的唯一方式是统一的账本&lt;/strong&gt;，并且对这个账本的要求是它必须是一个公共知识（common knowledge），可以简单理解成大家常说的共识。唯有这样，信息的副本才不会生效，比如黑客即便是黑了交易所复制了数据，也不可能重新搭建出一个交易所来让大家交易。至于如何达成这样的共识，是通过市场竞争，还是依赖权威机构，这里暂不讨论。&lt;/p&gt;

&lt;p&gt;现在区块链来了，要搞&lt;strong&gt;去中心化账本&lt;/strong&gt;。去中心化这个词是个热词，网上一直争论不休。由于时间关系这里不进行详细阐述，等有机会单独写文章阐述。这里只简单说明下我个人思考的去中心化的两个方面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;账本用户侧去中心化&lt;/strong&gt; 这个是从用户侧的准入机制上考量，比如传统媒体只有专业媒体人可以发布内容，到互联网门户，再到微博微信公众号等自媒体，本质上也是一种去中心化的过程。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;账本供给侧去中心化&lt;/strong&gt; 这个是从账本的供给角度考量。比如还是前面的例子，传统媒体有很多，各种报纸杂志，挂一个媒体影响不大，到门户时代就少了，再到现在基本就剩下几个平台了，挂一个平台影响就大了。那现在能不能再反过来，同一个账本由多个供给方一起提供？这样就兼具二者优势了。区块链主要关注的是这个方向。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至于为什么账本会向去中心化账本演进，动力在哪里，这里就不展开了。先从技术演进角度来理解一下，从中心化的账本到去中心化账本之间的技术演进过程。&lt;/p&gt;

&lt;h2 id=&quot;账本架构演进之路&quot;&gt;账本架构演进之路&lt;/h2&gt;

&lt;p&gt;我总结了这样一个演进过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/ledgers.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;单数据库账本&quot;&gt;单数据库账本&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/ledger1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个架构图做互联网应用的朋友应该看起来很亲切。早期的企业以及互联网应用都是这个样子的，应用界面面向最终用户，应用本身的程序封装了业务逻辑，应用状态直接存储到数据库中。这时候关注的账本相关技术主要是『&lt;strong&gt;事务&lt;/strong&gt;』。通过数据库提供的事务机制，保证了账本的原子性操作。&lt;/p&gt;

&lt;h3 id=&quot;分布式数据库账本&quot;&gt;分布式数据库账本&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/ledger2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当单机数据库无法承载读写或者数据的时候，就有了分布式数据库。分布式数据库的数据分散到了不同的节点，通过分片以及多副本来解决上述问题。但同时带来的问题是如何保证同一个分片在不同节点的数据的一致性以及跨节点的分布式事务。这时候账本相关技术主要是『&lt;strong&gt;分布式共识算法（paxos，raft ），分布式事务&lt;/strong&gt;』。分布式事务由于其复杂性，分布式数据库不一定能够提供，很多情况需要在业务逻辑里处理。&lt;/p&gt;

&lt;h3 id=&quot;多机房账本&quot;&gt;多机房账本&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/ledger3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着账本越来越重要，异地副本都不能满足需求，需要异地多活了，于是有了多机房方案。多机房方案里，不同的机房之间需要同步数据，并且保证一致性。这时候账本技术的挑战主要是『&lt;strong&gt;跨机房分布式共识算法，应用状态的复杂性&lt;/strong&gt;』。前者是说分布式共识算法需要考虑更复杂的网络场景，后者是说大部分应用的状态维护比较复杂，不仅仅在数据库中，只是通过一个跨机房复制工具把数据库状态复制过去，是很难应对多机房应用场景，实际上需要应用架构的改变。&lt;/p&gt;

&lt;h3 id=&quot;多运营方账本&quot;&gt;多运营方账本&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/ledger4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的账本都只考虑同一个主体运营维护的场景，内部的信任较高。但如果是多方共同维护一个账本的场景，也就是上一个方案的不同机房其实属于不同的主体。这样的场景下，另外一方无法直接信任应用的最终状态，所以在不同机房同步的不能是应用的状态，而是应用的 Event（事件）。无论是本机房用户写操作的 Event 还是从其他机房同步过来的，都需要经过业务逻辑校验处理后再变更应用状态。这实际就是 EventSource/CQRS 的架构，也是很多&lt;strong&gt;联盟链&lt;/strong&gt;的架构。多机房场景下其实也会用这种架构，主要区别是在对从其他机房同步过来的 Event 的信任度。这时候，账本技术的挑战除了&lt;strong&gt;跨机房分布式共识算法&lt;/strong&gt;，还有&lt;strong&gt;共识算法和业务逻辑融合&lt;/strong&gt;。在前面场景里的共识算法，基本只关心数据，不关心业务，共识算法只保证数据的一致性，并不保证数据在业务场景下的合法性。但在这个场景下，共识算法要保证只对合法的数据达成一致，二者融合了。无法直接沿用上面几种分布式共识算法，需要考虑作弊情况的共识算法，比如 BFT 这样的。&lt;/p&gt;

&lt;p&gt;有人会问，有什么动力要将同一个账本交给多个运营方呢？那我们拿互联网电商来说明这个场景。当前的电商，一方面对接商家和商家的库存管理系统，另外一方面对接银行和快递系统，以及最终用户。一个商品，从库存管理系统，到电商平台，用户购买后，从银行扣钱，发送快递，实际上是同一个账本上的信息在不同的运营方系统之间的同步。当前的实现方式是通过远程调用或者商家和用户介入手工操作。那不同的账本之间如何保证一致性呢？只能定时对账清算，因为远程调用本质上只是信息传递，无法保证一致性。如果这时候有个多方共享的账本，架构就会像上面那样，不仅架构更优雅，同时结算效率会更高。&lt;/p&gt;

&lt;p&gt;关于联盟链的技术架构以及模式的更详细分析，我会在下一篇文章中细说。&lt;/p&gt;

&lt;h3 id=&quot;去中心化账本&quot;&gt;去中心化账本&lt;/h3&gt;

&lt;p&gt;去中心化账本这个概念没有非常准确的定义，但我们这里可以简单的理解成 &lt;strong&gt;Peer to Peer 网络 + 账本&lt;/strong&gt;。Peer to Peer 网络的特征是无准入机制，给人的印象也是不可靠，更不追求一致性，而账本是要追求一致性的。比特币创造性的把二者结合起来。所以一般所说的去中心化账本，或者公链，关键一个特性就是&lt;strong&gt;无准入机制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;之前的账本都是有准入机制的，并且账本本身的运营成本以及收益通过系统外的机制来解决，那如果去掉准入限制，同时账本的运营成本以及收益也通过账本系统内置的机制来调节，会有哪些新的挑战？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何激励生产者？生产者为什么提供服务器资源？如何度量生产者的工作？&lt;/li&gt;
  &lt;li&gt;如何实现一致性？无准入机制的情况下，节点数不确定，随时加入退出，无法用 BFT 这样的投票共识算法。&lt;/li&gt;
  &lt;li&gt;如何防攻击？比如生产大量数据（DoS攻击），伪造大量节点（女巫攻击）。有了激励就有了攻击和作弊的利益动机，传统的 Peer to Peer 网络没有激励，一般人也不会做损人不利己的事情。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们通过几个公链是来分析上面的问题。&lt;/p&gt;

&lt;h2 id=&quot;bitcoin-a-peer-to-peer-electronic-cash-system&quot;&gt;Bitcoin: A Peer-to-Peer Electronic Cash System&lt;/h2&gt;

&lt;p&gt;比特币首先带给我们的是一套内生的激励机制。虽然比特币到底应该理解成货币，还是数字黄金，还是股票，大家争论不休。这里我们把比特币设想成一个创业公司，这个创业公司要做一个记账交易系统。于是它发行了2100万股，发行规则直接写到了这个记账系统的代码中，分期释放，奖励给给这个系统提供运行资源的人。而用户拿什么来交易呢？也用它的股票来做交易媒介。这样它就实现了软件系统在经济上的自举，也带给软件系统一种能力：&lt;strong&gt;在程序算法中引入经济博弈机制&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;proof-of-work&quot;&gt;Proof of Work&lt;/h3&gt;

&lt;p&gt;PoW 到底应该算是激励的评估机制，还是共识算法，还是反 DoS 策略？实际上它兼具多种功能。所以这也是公链的共识算法和传统分布式共识算法的差异之处，容易让人迷惑。&lt;/p&gt;

&lt;p&gt;最早应用 PoW 的是 hashcash，它的主要目的就是通过 PoW 来实现邮件的反垃圾，关键点是通过 PoW 制造额外成本，这样发邮件少的用户可以接受成本，但发垃圾邮件的用户就很难承担这样的成本。&lt;/p&gt;

&lt;p&gt;同时，有了成本也就可以作为贡献的评估标准，Proof of Work 这个词，顾名思义，就像是一个工作的评估机制。运行比特币系统，需要机房，机器，带宽等，如何通过程序来评估资源提供者的工作呢？比特币的做法就是算哈希函数，要求算出来的哈希值小于一个难度。虽然简单粗暴，但它难计算，易验证，是一种可行的办法。&lt;/p&gt;

&lt;h3 id=&quot;中本聪共识nakamoto-consensus&quot;&gt;中本聪共识（Nakamoto Consensus）&lt;/h3&gt;

&lt;p&gt;只有 PoW 是无法实现一致性的，需要再加上其他的一些策略，统称为中本聪共识。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;内置的校验机制（包括 hash 难度校验，merkle 校验，链式关系校验，UTXO 校验等），每个区块只认可通过校验的合法区块，拒绝非法区块。&lt;/li&gt;
  &lt;li&gt;最长链选择 如果由于网络延迟造成软分叉，每个节点应该在最长的一条链上继续工作。&lt;/li&gt;
  &lt;li&gt;如果有节点试图违反以上规则，则会带来经济成本（自己挖出的块不合法被拒绝，在短链上的工作不被认可等），通过经济上的博弈实现防作弊。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;中本聪共识的特点是无交互，纯异步，每个节点只需要按照内置的规则处理即可，无需和其他节点交互协调。&lt;/p&gt;

&lt;h3 id=&quot;区块与链式结构&quot;&gt;区块与链式结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/blockchain-overview.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比特币带来的区块与链式结构，也是区块链这个名字的由来。但区块和链式结构是必须的吗？真的存在一条这样的全局链式结构吗？实际上区块只是一种为了降低网络开销的批量操作，链式结构的主要目的是建立一种时间上的依赖关系，即便两个交易本身不相关，但由于链式结构的存在，后面的交易实际上给前面的交易做了背书，增加了篡改和回滚的成本，因为一旦想要撤回前面的交易，必然也会影响后来的交易。这种结构和关系只是共识协议的一部分，并不存在这样一个全局的结构，具体每个节点如何保存数据，是节点自己决定的。链式结构虽然存在分叉，但只要配合共识机制，最终可以选择出一条唯一的链，达到最终一致性。也就是说，只要能达到这个目标，区块和链式结构并不是必须的，也没必要因为这个名字纠结什么是真正的区块链。&lt;/p&gt;

&lt;h3 id=&quot;utxo-与-merkletree&quot;&gt;UTXO 与 MerkleTree&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/utxo.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;UTXO 本身是一种复式记账法。比特币的定位是数字货币，UTXO 属于它的账本业务逻辑。这种记账法的好处是任何一笔交易都可以回溯到创币交易，保证货币只能由创币交易产生，无法凭空产生。如果只是货币场景，UTXO 确实比 Account 模型要安全，但如果考虑到其他应用场景，应用的状态就很难设计出一种 UTXO 模型来追踪变更，这也是为什么后来的面向应用的链放弃 UTXO 的原因。&lt;/p&gt;

&lt;p&gt;比特币通过 MerkleTree 提供交易证明，方便没有全量账本的轻客户端校验交易。但比特币的 MerkleTree 是每个账本一个，没有全局 MerkleTree，也就是说没办法提供全局证明，轻客户端的实现就会比较复杂。这方面比特币社区也讨论很久，详情可以参看我以前的一篇文章：《&lt;a href=&quot;http://jolestar.com/blockchain-utxo-proof/&quot;&gt;谈谈区块链的 UTXO 证明&lt;/a&gt;》。后面会谈到 Ethereum 的改进。&lt;/p&gt;

&lt;h3 id=&quot;bitcoin-script&quot;&gt;Bitcoin Script&lt;/h3&gt;

&lt;p&gt;比特币的 Script 可以理解成一种支付校验逻辑的扩展能力。前面说了，去中心化账本的业务逻辑和共识机制融合在一起了，支付校验本身也属于业务逻辑。这种逻辑的变更会影响共识，进而可能导致硬分叉，而提供一种可自定义逻辑的脚本，则是一种兼顾的策略。&lt;/p&gt;

&lt;p&gt;同时，比特币的这种能力也给后来的染色币（Colored Coin）提供了机会。本来比特币的账本只能记录比特币的交易，但有了 Script 后，可以在 Script 嵌入自定义数据结构，可以理解成对比特币账本的数据扩展。染色币就利用这种机制来制造新的加密币。&lt;/p&gt;

&lt;p&gt;这种机制的好处是染色币不需要重新构建一个去中心化的账本网络，降低了时间以及经济成本。但缺点也很明显，一方面，这种目的毕竟不属于比特币的初始设想，得不到更多支持，另外一方面，比特币 Script 只能嵌入数据，无法嵌入对这种数据的校验逻辑，校验逻辑还需要通过部署独立的节点程序来实现。&lt;/p&gt;

&lt;p&gt;于是这种需求背景下，以太坊产生了。&lt;/p&gt;

&lt;h2 id=&quot;ethereum-a-decentralized-platform-that-runs-smart-contracts&quot;&gt;Ethereum: A Decentralized Platform that runs Smart Contracts&lt;/h2&gt;

&lt;p&gt;以太坊的设想是既然运行一个去中心化账本成本这么高，那能不能先运行一个通用的账本，然后提供机制允许用户在上面自定义业务逻辑？所以它的目的不是数字货币，而是运行『智能合约』的平台。如果说以太坊当前的 PoW 共识机制等只是在比特币 PoW 基础上的优化改良，它的最关键的创新就是智能合约和 Global State Trie。&lt;/p&gt;

&lt;h3 id=&quot;智能合约&quot;&gt;智能合约&lt;/h3&gt;

&lt;p&gt;这里顺便扯一下对『智能合约』的看法。很多批评『智能合约』的人说这只是一种脚本程序，并不智能。那这样说智能手机（Smart Phone）哪里智能了？智能家居，智能手表，智能xx不都一样？中文领域里把 Smart 和  Intelligence（Artificial Intelligence，AI 人工智能） 都翻译成智能，确实造成混淆。但这是历史遗留问题了，纠结这个名字没有意义。&lt;/p&gt;

&lt;p&gt;于是以太坊提供了一种图灵完备的脚本语言来定义业务逻辑，交易数据中明确允许嵌入自定义数据结构（以太坊 transaction 的 data 字段），链不关心合约本身的逻辑，只是通过在不同的节点重复运行合约，来保证合约的输出是确定的。它和比特币的 Script 的差异不仅在是否图灵完备，更大的差异在于自定义数据和自定义逻辑的结合。染色币这样的场景，它同时托管了染色币的账本数据和交易逻辑，于是引来了一场发币的热潮。它这种机制带来的挑战是不同的场景的业务逻辑的输入输出不一样，如何存储和维护？如何提供证明？&lt;/p&gt;

&lt;p&gt;于是它创造性的引入了 &lt;strong&gt;Global State Trie&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;global-state-trie&quot;&gt;Global State Trie&lt;/h3&gt;

&lt;p&gt;以太坊的黄皮书中通过一个公式来定义以太坊。&lt;/p&gt;

\[\sigma_{t+1}\;\equiv\;\Upsilon(\sigma_t,\;T)\]

&lt;p&gt;这个公式中的 \(\sigma\) 代表以太坊的状态，\(\Upsilon\) 代表处理函数（包括合约以及内置的 Ether 交易逻辑），T 代表交易（包含调用合约的交易）， t+1 的状态等于处理函数在 t 状态基础上处理 T 的执行结果。&lt;/p&gt;

&lt;p&gt;而这里的状态的程序表达形式就是一个 Merkle Patrica Trie。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://jolestar.com/images/blockchain/mpt.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一个两层的 Trie，第一层的叶节点上保存的是每个 Account 的余额（Balance），以及针对合约 Account 的 CodeHash 和 Storage root。Storage root 是另外一个 Trie 结构，叶节点是合约内部的状态。任何一个 Account 的余额或者合约状态变更，都会导致 Global State Root 变更，而每个区块都会在区块头上带上当前区块中的 Transaction 执行完后的 State Root 。&lt;/p&gt;

&lt;p&gt;这样，一方面提供一种全局校验机制，只要比较 State Root 就可以快速知道不同节点的状态是否一致，这个和 Git 中引入 Merkle hash 证明机制的原理是一样的。Linus 一次分享 Git 的时候也说了，Git 的这种机制可以让他方便的信任来自第三方保存的代码。有了这套机制后，新节点同步的时候可以信任一定区块以前的全局状态，而不是完全通过区块回放来重新构建。这也回答了我们前面提出的那个问题，如何快速校验不同机房的数据状态一致性。&lt;/p&gt;

&lt;p&gt;另外一方面，它也提供了一种单个账号状态和全局状态关系的证明能力，可以通过 Merkle Path 证明一个账号的当前状态和全局状态之间的关系，轻钱包实现就会更容易。&lt;/p&gt;

&lt;p&gt;如果纯粹从模型看，以太坊已经是一个非常理想的模型了。大家常说程序就是数据结构加算法，它既提供了数据结构的自定义以及存储能力，也提供了算法的计算环境，理论上任何程序都可以放上去运行了。但套用一句俗话，理想是丰满的，现实是骨感的，这样的全球分布式账本的存储和计算成本太高了，稍微复杂的应用都很难运行起来。&lt;/p&gt;

&lt;h2 id=&quot;eosthe-most-powerful-infrastructure-for-decentralized-applications&quot;&gt;EOS:The most powerful Infrastructure for Decentralized Applications&lt;/h2&gt;

&lt;p&gt;EOS 自项目启动开始，主打的旗帜就是吞吐和性能。如果说比特币和以太坊两个项目带有一种理想主义特质，EOS 则带有非常明显的实用主义特质。&lt;/p&gt;

&lt;p&gt;前面说到，Peer to Peer 网络的问题是无准入，节点数不固定，匿名情况下防作弊成本高。EOS 的 DPoS 思路就是通过投票选举，让参与共识的节点在一定时间内保持稳定，同时通过竞选机制，让竞选节点不再匿名，降低防作弊的成本，然后把注意力集中到吞吐以及应用模型的改进上。&lt;/p&gt;

&lt;p&gt;互联网应用开发者看了 EOS 的应用模型后，会感觉更容易理解。看它的 ABI 描述文件，第一眼的感觉就像是在定义应用表结构。它交易结构中直接嵌入的是 Message，相当于 EventSource 架构中的 Event。以太坊的链上还保留了 Ether 本身的交易逻辑，而 EOS 上 EOS Token 本身也是通过合约实现的，只是合约分为系统合约和用户应用合约，整个链成为了一个更纯粹的合约执行平台。&lt;/p&gt;

&lt;p&gt;EOS 中没有 Global State Trie，这个问题 Vitalik 和 BM 争论过很多次，这代表了两种不同的思维方式，感兴趣的人可以找来看看，我个人是同意 Vitalik 的看法的。&lt;/p&gt;

&lt;p&gt;EOS 另外两个值得关注的点是它的经济模型以及链上治理模型。它试图提供免费的交易，但毕竟资源有限，所以通过其他限制来替代交易费模式。链上治理带来的启示是，大家常说的共识到底包含哪些方面？代码中的共识逻辑？最终的一致性账本？社区的用户选择是否也可以沉淀到链上，以解决分歧以及约束区块生产者（矿工）？&lt;/p&gt;

&lt;h2 id=&quot;到底需要多少去中心化账本&quot;&gt;到底需要多少去中心化账本？&lt;/h2&gt;

&lt;p&gt;前面我们分析了账本的架构演进以及几条典型的公链。如果说比特币是一个区块链应用的演示，以太坊和 EOS 则可以看成应用实验平台。那到底世界需要多少去中心化账本？多少条公链？通用公链的扩展性困境不仅仅来自技术层面的容量和吞吐，同时也来自应用方向。做一个有无限可能的链，还是一个和具体业务逻辑绑定的链？是新链开发者必须要面临的选择。&lt;/p&gt;

&lt;p&gt;当前的情况下，通过分片来解决扩展性（容量和吞吐）问题的复杂度过高，短期很难落地，于是社区提出了分层的概念。&lt;/p&gt;

&lt;p&gt;Layer2 的道理很简单，也符合大家的认知常识。不同的账本需要的安全级别以及共识范围是不一样的，没必要每个交易都需要全球共识。但关键是怎么做到呢？&lt;/p&gt;

&lt;p&gt;它的核心思路是通过 Layer1（链层）提供的机制来约束 Layer2，具体方案可分为两种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;状态通道&lt;/strong&gt;（比如闪电网络）顾名思义，它主要是两个人之间的一个通道，相当于两个人之间的一个账本。因为每个账本只有两个人，所以账本上只需记录每个人的最终状态，无需记录每次交易，最后按最终状态分账就行，没有直接通道的用户之间可以通过路由中转的方式来进行交易。链提供机制，避免作弊以及不合作风险，具体安全策略这里不详述，有兴趣的朋友看我的视频&lt;a href=&quot;http://jolestar.com/lightning-network-and-layer2/&quot;&gt;10分钟理解闪电网络以及区块链二层解决方案的原理&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;多方链下账本&lt;/strong&gt; 如果是多个人之间可以直接互相交易，又不希望建立过多通道（成本原因），就只能通过维护一个多人的共同账本来实现了。这个账本也必须找到托管方，但关键是如何保证安全。我们传统的账本安全其实是靠审计，用户以及第三方监督等机制实现，那能不能把这套机制也在链上实现？链用来公示以及争议裁判（双方需要提供证明，程序自动判决），用户和账本托管方互相监督，再或者引入其他托管方把账本变成一个联盟链。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于 Layer2 的各种方案的探索，至少给我们展示了一个可能，就是各种账本之前并没有泾渭分明的界线，会有机制将它们混合在一起，共同形成价值网络，后面会写再文章单独分析。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;本文整体从账本的作用以及架构演进来阐释区块链。阐释区块链的方式有很多种，我这里主要以技术演进的角度进行。&lt;/p&gt;

&lt;p&gt;早就想写一个系列，谈谈区块链，但年初的时候区块链鼓吹者甚多，作为一个技术人，完全插不上嘴。最近熊市，冷清了许多，连区块链是一种落后技术的言论都出来了，于是决定写一写。&lt;/p&gt;

&lt;p&gt;区块链绝对不是一种落后的技术，而是一种更优秀的分布式系统。同时它带来的技术挑战和契机也非常大，以前我们主要关心数据如何计算以及存储，区块链时代我们更要关心如何证明，从存储到计算整个体系都会有变革的契机。&lt;/p&gt;

&lt;p&gt;同时，它引入了经济体系，以及链上治理机制，有超越技术的深远的影响，不过这个话题就更大了，我会在另外的文章中探讨。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关链接&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;公共知识（common knowledge），博弈论的概念，所有人都知道，所有人都知道所有人都知道，所有人都知道所有人都知道所有人都知道的知识，李永乐老师有一期视频讲的很好，有兴趣的可以看下，&lt;a href=&quot;https://weibo.com/3325704142/GrwezA3Xm&quot;&gt;https://weibo.com/3325704142/GrwezA3Xm&lt;/a&gt; 。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jolestar.com/blockchain-utxo-proof/&quot;&gt;谈谈区块链的 UTXO 证明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jolestar.com/lightning-network-and-layer2/&quot;&gt;10分钟理解闪电网络以及区块链二层解决方案的原理&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 19 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/blockchain-technology-overview/</link>
        <guid isPermaLink="true">http://jolestar.com/blockchain-technology-overview/</guid>
        
        <category>blockchain</category>
        
        <category>ledger</category>
        
        <category>bitcoin</category>
        
        <category>etherum</category>
        
        <category>eos</category>
        
        
      </item>
    
      <item>
        <title>视频-Khipu 的存储引擎 Kesque 介绍</title>
        <description>&lt;p&gt;Khipu 是一个基于 Scala/Akka 的 Ethereum 实现，它的存储引擎 Kesque 很有特点。这是我在 BFTF 数据结构与存储 meetup 上的分享。&lt;/p&gt;

&lt;!--more--&gt;

&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=36797356&amp;amp;cid=64619875&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;100%&quot; height=&quot;600px&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;&lt;strong&gt;相关链接&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;BFTF meetup slides 地址 &lt;a href=&quot;https://github.com/bftfio/meetup&quot;&gt;https://github.com/bftfio/meetup&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 28 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://jolestar.com/kihup-and-kesque-introduction/</link>
        <guid isPermaLink="true">http://jolestar.com/kihup-and-kesque-introduction/</guid>
        
        <category>blockchain</category>
        
        <category>ethereum</category>
        
        <category>kihup</category>
        
        <category>kesque</category>
        
        
      </item>
    
  </channel>
</rss>
